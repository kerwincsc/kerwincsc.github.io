BASH
======================================================================

Shell 基本特性
------------------------------------------------------------

shell 操作
++++++++++++++++++++++++++++++++++++++++++++++++++

shell 的执行顺序:
#. 从一个文件, 从一个由 **-c** 调用选项提供的字符串, 或者从用户终端读取输入;
#. 遵循引用规则, 将输入分解为单词和运算符;
   这些符号被元字符分隔;
   别名扩展也在这步执行;
#. 将这些符号解析成简单的且混合的命令;
#. 执行 shell 的变量扩展, 将扩展开的符号分解成文件名, 命令和参数的列表;
#. 执行所有必要的重定向, 然后从参数列表中移除所有的重定向符号和它们操作对象;
#. 执行命令
#. 可选择地等待命令的完成(&), 然后收集它的退出状态;

引用
++++++++++++++++++++++++++++++++++++++++++++++++++

引用是用来移除对 shell 有特殊意义的字符或单词.

引用可被用来取消对特殊字符的特殊对待,
防止保留字被识别和防止参数扩展;

三种引用机制:

- 转义字符 ``\``
  对特定字符进行转义;
  如果一命令命令过长, 需要折行书写, 使用 / 确保是同一行的命令;

- 单引号 ``'``
  以单引号闭合的字符在单引号中保留了每个字符的字面值;
  一个单引号不会出现在单引号之间, 即使它的前面有一个反斜杠;

- 双引号 ``"``

  双引号里的字符将保留其字面值,
  以下除外: ``$ ` \`` 和打开历史展开功能时的 ``!``

  当处于 POSIX 模式中:
    - 即使打开了历史展开功能,
      双引号内的 **!** 也没有特殊意义;
    - 双引号中的'$' 和 '`' 保留自身的特殊意义;
    - 反引号后仅跟着如下符号: '$' , '`', '"', '\' 或者 *newline* 时,
      才保留其特殊意义;
    - 在双引号内, 被这些字符跟随的反斜杠将被移除.
    - 没有特殊意义字符之前的反引号将不作修改(不会被移除).

  在双引号里的一个双引号, 它之前有反引号的可被引用;

  如果打开, 除非出现在双引号内的 '!' 使用反引号逃逸, 否则历史命令展开将被执行;
  在 '!' 之前的反引号不会被移除;

  出现在双引号里的特殊字符 '*' 和 '@' 有特殊的意义;


shell 命令
++++++++++++++++++++++++++++++++++++++++++++++++++

- 命令的退出状态
  如果命令被信号终止, 则退出状态为 128+信号数;
  比如, 被 Ctrl+c 中止的命令退出状态码是 130(128+2);

管道
++++++++++++++++++++++++++++++++++++++++++++++++++

- ``|   |&``
- ``command1 |& command2``
  将 command1 的标准输出和标准错误作为 command2 的输入;
  等同于 **command1 2>&1 | command2** ;
- 标准错误到标准输出的隐式重定向在任一由命令指定的重写向之后被执行;
- time / time -p
  time -p 以 posix 形式输出时间;

  time 在 posix 模式下是没有多余的选项的, 其后跟 **-** 将会报错;

- `TIMEFORMAT` 显示命令的执行时间;

命令列表
++++++++++++++++++++++++++++++++++++++++++++++++++

- 命令列表是被 ``; & && ||`` 中的某个分隔的一个或多个管道的序列;
- 列表操作符中, **&&** 和 *||* 优先级相同, *;* 和 *&* 优先级相同;
- 一个或多个换行符的序列可能出现在列表中以分隔命令, 其等价于分号;
- 当作业控制不活动时, 异步命令的标准输入 (在没有任何显式重定向功能的情况下)
  将从 /dev/null 被重定向
- 被 ; 分隔的命令依次被执行;
  shell 轮流等待每个命令去终结;
  最后一个命令的退出状态作为整个命令列表的退出状态;
- and 和 or 列表:
  ``cmd1 && cmd2`` 仅当 cmd1 的退出状态为 0, 才执行 cmd2;

  ``cmd1 || cmd2`` 仅当 cmd1 的退出状态不为 0, 才执行 cmd2;

复合命令
++++++++++++++++++++++++++++++++++++++++++++++++++

循环构造
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
- until

  - ``until test-commands; do consequent-commands; done``
  - 只要 test-commands 的退出状态 *非零* , 就执行;

    直到 test-commands 的状态为 0, 才退出循环;

  - 最后一个命令的退出状态作为整体的返回值, 如果未执行, 就返回 0;

- while

  - ``while test-commands; do consequent-commands; done``
  - 只要 test-commands 的退出状态为 0, 就执行循环; 其余同上;

- for

  - ``for name [ [in [words …] ] ; ] do commands; done``

    - 将 *word* 展开为结果列表, 并为每一个在结果列表中的成员执行一次 *commands* ,
      带有绑定了当次循环成员的 *name* ;
    - 如果 *in word* 未指定, 则每一个位置参数上执行一次,
      就像是 ``for name in "$@"`` ;
    - 退出状态同上;
      
  - ``for (( expr1 ; expr2 ; expr3 )) ; do commands ; done``

    - 类 C 的循环结构
    - expr1 首先被求值;
    - 然后 expr2 被重复求值, 直到求值为 0;
    - expr2 被求值后, 不为 0, 则执行 **commands** ,
      然后对 expr3 求值;
    - 如果任一部分缺失, 则相当于被求值为 1;

      ``for ((;;));do echo hello;done`` 等价于 ``while ; do echo hello; done``

- until, while, for三者基本可互相替换, 并且都需要 do done;

条件构造
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- if

::

    if test-commands; then
      consequent-commands;
    [elif more-test-commands; then
      more-consequents;]
    [else alternate-consequents;]
    fi

   #. *test-commands* 首先被执行, 如果返回状态为 0,
   #. *consequent-commands* 被执行, 如果返回状态不为 0,
   #. 每一个 elif 列表将依次被执行, 如果返回状态为 0, 则执行 *more-consequents* ,
   #. 如果存在 else 列表, 且上面的所有 if 和 elif 的返回状态不为 0, 则执行 *alternate-consequents* ;

- case

::

   case word in [ [(] pattern [| pattern]…) command-list ;;]… esac

  - 有选择执行命令列表;
  - 如果 **nocasematch** [#nocasematch]_ 被启用, 则在不考虑字母字符大小写的情况下执行匹配操作;
  - `|` 被用来分隔多个匹配模式;
  - `)` 被用来终结匹配模式列表;
  - 一个匹配模式列表和与之相关的命令列表构成一个从句
  - 每个从句必须以 ``;;`` , ``;&`` , ``;;&`` 终结.

    - 使用 *;;* , 第一次匹配后, 不会继续向下匹配;
    - 使用 *;&* , 匹配执行后, 执行 ;& 后面的从句(不需要重新匹配, 直接执行), 如果有的话;
    - 使用 *;;&* , 匹配执行后, 执行 ;;& 后的从句的匹配, 如果匹配, 则继续执行;
  - 使用 ``*`` 作为最后的匹配模式以定义默认的情况;
  - 没有一个匹配, 则返回 0, 否则就最后一个命令的退出状态;

- select

::

   select name [in words …]; do commands; done

  - 与 for 几乎相同的语法;
  - *in* 后的 *word* 列表被扩展生成一个项目列表;
  - 展开的 words 集被打印到标准错误输出流上, 且每个前面有一个数字;
  - 如果没有 *in words* , 就会打印位置参数, 就像指定了 *$@* ;
  - PS3 提示被显示, 然后从标准输入读取一行;
  - 输入对应行行前的数字, *name* 的值被设置为那行的词;
  - 如果没输入直接回车, 则会再显示一次数字和词;
  - 如果读取到 *EOF* , 命令终结;
  - 读取到其它的数字值, *name* 的值将为空;
  - 每进行一次选择, *commands* 被执行一次, 除非遇到 *break*,

- ((...))

::

   (( expression ))

  - 与 ``let "expression"`` 完全相同;
  - 如果表达的值 **非0** , 则返回状态为 **0** ; 其它情况返回 **1** ;

- [[...]]

::

   [[ expression ]]

  - 返回状态是 0 还是 1, 取决于条件表达式 *expression* ;
  - 在 *[[ 和 ]]* 之间:

    - 不会执行 *单词分拆* 和 *文件名扩展*;
    - 会执行 *波浪线扩展*, *参数及变量扩展*, *算术扩展*, *命令替换*, *进程替换* 和 *引用移除*;

  - 条件操作符, 如 *-f*, 不能被引用;
  - 当 *<* 和 *>* 与 *[[* 一起使用时, 使用当前字符集的字典序进行排序;
  - 当使用 *==* 和 *!=* 时, 操作符右边的字符串被当成一个模式, 并按照匹配规则进行匹配,
    就好像开启 *extglob* shell 选项;
  - *=* 与 *==* 完全相同;
  - 如果启用了 *nocasematch* shell 选项, 则在不考虑字母字符大小写的情况下执行匹配操作;
  - 如果字符匹配了(==)或者不匹配(!=), 返回值为 0;
  - 模式的任一部分可被引用以强制被引用部分被作为字符串匹配;


  - 另一个二元运算符, *=~* , 可用, 其优先级与 '==' 和 '!=' 相同;
  - 使用时, 运算符右边的字符串被认为是扩展的正则表达式, 然后相应地匹配;
  - 匹配了, 则返回 0, 否则返回 1;
  - 如果正则表达式语法有误, 则条件表达式返回 **2**;
  - 如果启用了 *nocasematch* shell 选项, 则在不考虑字母字符大小写的情况下执行匹配操作;
  - 模式的任一部分可被引用以强制被引用部分被作为字符串匹配;
  - 正则表达式中的括号表达式必须仔细处理, 因为正常的引用字符在括号之间失去其含义;
  - 如果模式存储在 shell 变量中, 引用那个变量扩展强制将整个模式匹配为字符串;
  - 在正则表达式中, 被带括号的子表达式匹配的子字符串被保存在数组数量 *BASH_REMATCH* ;
  - 索引为 0 的 BASH_REMATCH 的元素是匹配了整个正则表达式的字符串的那部分;

    索引为 n, 则是第 n 个括号子表达式匹配的子字符串的那部分;

分组命令
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- 提供两种分组命令
- 当命令被分组时, 重定向功能可以应用于整个命令列表
- ()

::

   ( list )

  - 放在括号间的命令列表将会引发 **子shell** 环境的创建, 然后每个命令列表中的命令将在子 shell 中执行;
  - 因为命令在子shell中执行, 所以命令完成后分配的变量不会保留;

- {}

::

   { list; }

  - 放在大括号中的命令列表将使命令列表在 **当前shell** 中执行;
  - 不会创建子shell;
  - 跟在 *list* 后面的分号(或者换行)是需要的;

- 除了创建一个 subshell, 由于历史原因, 这两种构造之间存在着微妙的差别;
- 大括号是保留字, 因此必须用空格或其他 shell 元字符将它们与列表隔开;
- 括号是运算符, 并且由 shell 识别为单独的标记, 即使它们没有按空格与列表分开;


  

历史记录
------------------------------------------------------------

``-o history`` 打开;

#. shell 变量
   **HISTSIZE** 历史记录大小, 默认500;

   **HISTIGNORE and HISTCONTROL**

   **HISTFILE** 默认值是 ~/.bash_history, bash 启动时读取此变量指定的文件
   中的记录作为历史记录;
   
   **HISTFILESIZE**
   
   **HISTTIMEFORMAT**

#. shell 选项
   histappend
   
   cmdhist
   
   lithist

#. 内置命令

  fc [#fc]_ [-e ename] [-lnr] [first] [last]

  fc -s [pat=rep] [command]

fc -l 仅列出最近的 16 条命令;

fc -l 100 仅列出 第100条到最近一条的命令;

fc -l 10 100 列出指定范围的命令;

fc -l -n 列出命令时, 不显示命令的序号;

fc -l -r 反向列出命令;

fc -e emacs 以 emacs 打开并显示最近一条命令;

   

#. 变量 ``FCEDIT`` 指定了显示或修改命令的编辑器

.. rubric:: 注

.. [#fc] Fix Command;
.. [#nocasematch] 通过 shopt 开关;

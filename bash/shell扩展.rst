shell扩展
======================================================================

shell有7种扩展:

   
花括号扩展
------------------------------------------------------------

介绍: 花括号展开是一种可以产生任意字符串的机制;

特性:

  - 展开优先级最高, 开展后保留其它展开的特殊字符;
  - 可嵌套;
  - 展开结果不会被排序;
  - 从左向右展开;
  - 形如 {x..y[..incr]}, 是序列展开, *incr* 是步长, x 和 y 必须同时是单字符或是数字;

    此序列可以是递增的, 也可以是递减的; 递减时, *incr* 既可以是正数也可以是负数,
    且只能是整数;

  - BASH 对花括号内的扩展或文本的上下文不应用任何句法解释;

    为了防止与参数展开产生冲突, 字符串“${”不被当作是花括号扩展的合格条件;

格式正确的括号展开式必须包含无引号的开括号和关括号，以及至少一个无引号的逗号或有效的序列表达式;

可以用反斜线引用 { 或 “,”, 以防止它被看作括号表达式的一部分;

举例:

  ::

     bash$ echo a{d,c,b}e
     ade ace abe

     bash$ echo a{2..6} ; echo a{c..f}c
     a2 a3 a4 a5 a6
     acc adc aec afc

     bash$ echo a{6..2..-2}c ; echo a{6..2..2}c
     a6c a4c a2c
     a6c a4c a2c

     bash$ echo a{a..g..2} ; echo a{g..a..3} ; echo a{g..a..-3}
     aa ac ae ag
     ag ad aa
     ag ad aa

     bash$ echo a{a..z..c}
     a{a..z..c}


波浪号扩展
------------------------------------------------------------

如果一个单词以一个未被引用的波浪字符('~')开始,
所有的直到第一个未引用的斜线的字符(或者是所有的字符, 如果没有未被引用的斜线)被认为是一个 *波浪号前缀*;


特性:

  - 如果波浪号前缀内没有字符被引用, 则波浪号前缀中, 跟着波浪号的字符串将被当成是 **登录名**;

    ::

       ~foo # 这种形式将把 foo 当成是用户名; 如果不存在 foo 用户, 则报错;
            # 配合 cd 使用, 则进行 foo 用户家目录;


    如果登录名为空字符串, 波浪号将被 shell 变量 **HOME** 所替换 [#]_;

    如果 **HOME** 未设置, 将被替换成用户执行 shell 的家目录;
    不然, 波浪号前缀将被替换成与指定登录名相关的家目录;

  - 如果波浪号前缀是 **~+** , shell 变量 **PWD** 的值将替换波浪号前缀;

    ::

       echo ~+ # 值等于 pwd 命令的返回结果;
               # 在脚本中使用代替 pwd;

    如果前缀是 **~-** , 将被替换成 shell 变量 **OLDPWD** [#]_ , 如果有的话;

    ::

       cd ~-/foo # 进入前一个目录的 foo 目录;


  - 如果波浪号后跟着数字 *N*, 或者跟着 *+N* 或 *-N*, 波浪前缀将被目录堆栈中的相应元素替换 [#]_,
    如同它通过在波浪前缀中跟着波浪号的字符作为参数调用了内置命令 *dirs* 被显示一样;

    ::

       ~N  === dirs +N  === ~+N
       ~-N === dirs -N

    如果波浪前缀由不带前导的 '+' 或 '-' 的数字组成, 那么就假定是 '+';

shell 参数扩展
------------------------------------------------------------

'$' 作为参数扩展, 命令替换, 或者算术扩展的开头;
要展开的参数名称或符号可以括在大括号中, 这是可选的, 但它有助于保护变量,
使其从紧跟其后的字符中展开, 可以将其解释为名称的一部分;

当使用大括号时, 匹配结束大括号是第一个未被反引号逃脱或者不在引用字符内,
并且不在嵌套的算术表达式, 命令替换或者参数扩展中;

参数扩展的基本形式是 **${parameter}** . **parameter** 的值将被替换.
*parameter* 可以是上面说的 shell 参数或者数组引用;
当 *parameter* 是具有多个数字的位置参数时, 或者当参数后跟不被解释为其名称的一部分的字符时,
则需要使用大括号;

如果 *parameter* 的第一个字符是惊叹号(!), 并且这个 *parameter* 不是一个 *nameref*,
它将引入一个间接变量的级别;
bash 使用由 *parameter* 剩余部分形成的作为变量名的变量的值, 然后此值被扩展并在余下的扩展中使用,
而不是 *parameter* 的值自身; 这叫间接扩展; 如果 *parameter* 是 *nameref* ,
这将扩展到被 *parameter* 引用的变量的名字以取代执行完全间接扩展;
但是有例外: 就像下面所说的 *${!prefix*}* 和 *${!prefix[@]}* ;
感叹号必须紧跟着左大括号以产生间接;

当不执行子字符串扩展时，请使用下面描述的形式;
Bash 测试参数其值是未设或者为空; 省略冒号导致仅测试参数是否未设;
换句话说, 如果包括冒号, 操作符将检测 *parameter* 是否存在并且它的值是否为空;
如果省略冒号, 仅检测存在性;

::

   ${parameter:-word}   # 若 parameter 未设或为空, 将替换为 word 的扩展; 否则就替换为 parameter 的值;
   ${parameter:=word}   # 若 parameter 未设或为空, word 的扩展将被分配给 parameter;
                        # 接着, parameter 的值被替换; 位置参数和特殊参数不会以这种方式被分配;
   ${parameter:?word}   # 若 parameter 未设或为空, word (如果 word 不存在,
                        # 则提示 parameter 未设或者为空) 的扩展将被写到标准错误,
                        # 且 shell 将退出, 如果此 shell 是非交互式的;
			# 否则, 将被替换 parameter 的值;
   ${parameter:+word}   # 如果 parameter 未设或为空, 什么都不会被替换; 否则, 将替换为 word 的扩展;



- ``${parameter:offset}``  ``${parameter:offset:length}``

  这叫子字符串扩展; 扩展到从 *offset* 指定的字符开始的 *length* 个长度的 *parameter* 值的字符串；
  如果 *parameter* 是 '@' 字符, 一个由  '@' 或  或 '*'的索引数组, 或者关联数组名, 将与下述有所不同.
  如果省略 *length* ，将扩展到由 *offset* 开始的字符到 *parameter* 值结束的子串;
  *length* 和 *offset* 是算术表达式;

  如果 *offset* 求值为小于 0 的数字, 该值被用作一个在字符串里从 *parameter* 值的结尾的偏移;
  如果 *length* 求值为小于 0 的数字, 将被解释为一个在字符串里的从 *parameter* 值的结尾的偏移而不是多个字符,
  并且扩展是 *offset* 和那个结果之间的字符串;
  注意, 负偏移必须被至少一个空格跟着的冒号分隔以防止与 ’： 扩展混淆;

  ::

     $ string=0123456789abcdefgh
     $ echo ${string:7}
     7890abcdefgh
     $ echo ${string:7:0}
     
     $ echo ${string:7:2}
     78
     $ echo ${string:7:-2}
     7890abcdef
     $ echo ${string: -7:0}
     
     $ echo ${string: -7:2}
     bc
     $ echo ${string: -7:-2}
     bcdef
     $ set -- 01234567890abcdefgh
     $ echo ${1:7}
     7890abcdefgh
     $ echo ${1:7:0}
     
     $ echo ${1:7:2}
     78
     $ echo ${1:7:-2}
     7890abcdef
     $ echo ${1: -7}
     bcdefgh
     $ echo ${1: -7:0}
     
     $ echo ${1: -7:2}
     bc
     $ echo ${1: -7:-2}
     bcdef
     $ array[0]=01234567890abcdefgh
     $ echo ${array[0]:7}
     7890abcdefgh
     $ echo ${array[0]:7:0}
     
     $ echo ${array[0]:7:2}
     78
     $ echo ${array[0]:7:-2}
     7890abcdef
     $ echo ${array[0]: -7}
     bcdefgh
     $ echo ${array[0]: -7:0}
     
     $ echo ${array[0]: -7:2}
     bc
     $ echo ${array[0]: -7:-2}
     bcdef


  如果参数是 ’@‘， 结是从 *offset* 开始的 *length* 个长度的位置参数;
  接受一个比最大位置参数大的负 *offset* , 这样一个 *-1* 的偏移到最后的位置参数;
  如果 *length* 求值为一个小于 0 的数字, 将引起扩展错误;

  ::

     $ set -- 1 2 3 4 5 6 7 8 9 0 a b c d e f g h
     $ echo ${@:7:0}
     
     $ echo ${@:7:2}
     7 8
     $ echo ${@:7:-2}
     bash: -2: 子串表达式 < 0
     $ echo ${@: -7:2}
     b c
     $ echo ${@:0}
     bash 1 2 3 4 5 6 7 8 9 0 a b c d e f g h
     $ echo ${@:0:2}
     bash 1
     $ echo ${@: -7:0} # 返回空


  如果 *parameter* 是一由 '@' 或 '*' 做下标的索引数组名,
  该结果将是以 *${parameter[offset]}* 开始的 *length* 个长度的数组成员;
  接受一个相对大的指定数组最大索引的负的 *offset* ;
  如果 *length* 求值为一个比 0 小的数字, 将引起扩展错误;

  ::
     
     $ array=(0 1 2 3 4 5 6 7 8 9 0 a b c d e f g h)
     $ echo ${array[@]:7}
     7 8 9 0 a b c d e f g h
     $ echo ${array[@]:7:2}
     7 8
     $ echo ${array[@]: -7:2}
     b c
     $ echo ${array[@]: -7:-2}
     bash: -2: 子串表达式 < 0
     $ echo ${array[@]:0}
     0 1 2 3 4 5 6 7 8 9 0 a b c d e f g h
     $ echo ${array[@]:0:2}
     0 1
     $ echo ${array[@]: -7:0}
     
  应用于关联数组的子串扩展产生未定义的结果;

  子串索引是基于 0 的, 除非使用了位置参数, 在这种下, 索引默认以 1 开始;
  如果 *offset* 是 0 且使用了位置参数, 则 '$@' 被前缀到列表中;

- ``${!prefix*}``  ``${!prefix@}``

  扩展成以 *prefix* 开始的由 **IFS** 特殊变量的第一个字符分隔的变量的名称;
  当使用 '@' 且扩展出现在双引号里, 每一个变量名将扩展为一个独立的词;

- ``${!name[@]}``  ``${!name[*]}``

  如果 name 是数组变量, 将扩展成数组索引的列表;

  如果 name 不是数组, 如果 name 被设定将扩展为 0, 否则扩展为空;

  当使用 '@' 并且扩展出现在双引号中时, 每一个键将扩展为独立的词;

- ``${#parameter}``

  替换为 *parameter* 的扩展值以字符方式的长度;
  如果 *parameter* 是 '*' 或者 '@' , 替换的值是位置参数的个数;
  如果 *parameter* 是以 '*' 或者 '@' 作下标的数组名, 替换的值将是数组中元素的个数;
  如果 *parameter* 是一个以负数作下标的索引数组名, 则该数被解释为相对于大于 *parameter* 最大索引的一个数,
  所以负索引从数组末尾开始计数, 且索引 -1 引用最后一个元素;


.. rubric:: Footnotes

.. [#] 即 ~ 总是代表当前用户名;
.. [#] 即上一个之前的那个 PWD;
.. [#] 要配合 pushd popd dirs 一起使用才能看出效果, 注意, N 从 0 开始索引, -N 是反向索引目录栈;

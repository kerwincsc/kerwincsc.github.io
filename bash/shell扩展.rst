shell扩展
======================================================================

shell有7种扩展:

   
花括号扩展
------------------------------------------------------------

介绍: 花括号展开是一种可以产生任意字符串的机制;

特性:

  - 展开优先级最高, 开展后保留其它展开的特殊字符;
  - 可嵌套;
  - 展开结果不会被排序;
  - 从左向右展开;
  - 形如 {x..y[..incr]}, 是序列展开, *incr* 是步长, x 和 y 必须同时是单字符或是数字;

    此序列可以是递增的, 也可以是递减的; 递减时, *incr* 既可以是正数也可以是负数,
    且只能是整数;

  - BASH 对花括号内的扩展或文本的上下文不应用任何句法解释;

    为了防止与参数展开产生冲突, 字符串“${”不被当作是花括号扩展的合格条件;

格式正确的括号展开式必须包含无引号的开括号和关括号，以及至少一个无引号的逗号或有效的序列表达式;

可以用反斜线引用 { 或 “,”, 以防止它被看作括号表达式的一部分;

举例:

  ::

     bash$ echo a{d,c,b}e
     ade ace abe

     bash$ echo a{2..6} ; echo a{c..f}c
     a2 a3 a4 a5 a6
     acc adc aec afc

     bash$ echo a{6..2..-2}c ; echo a{6..2..2}c
     a6c a4c a2c
     a6c a4c a2c

     bash$ echo a{a..g..2} ; echo a{g..a..3} ; echo a{g..a..-3}
     aa ac ae ag
     ag ad aa
     ag ad aa

     bash$ echo a{a..z..c}
     a{a..z..c}


波浪号扩展
------------------------------------------------------------

如果一个单词以一个未被引用的波浪字符('~')开始,
所有的直到第一个未引用的斜线的字符(或者是所有的字符, 如果没有未被引用的斜线)被认为是一个 *波浪号前缀*;


特性:

  - 如果波浪号前缀内没有字符被引用, 则波浪号前缀中, 跟着波浪号的字符串将被当成是 **登录名**;

    ::

       ~foo # 这种形式将把 foo 当成是用户名; 如果不存在 foo 用户, 则报错;
            # 配合 cd 使用, 则进行 foo 用户家目录;


    如果登录名为空字符串, 波浪号将被 shell 变量 **HOME** 所替换 [#]_;

    如果 **HOME** 未设置, 将被替换成用户执行 shell 的家目录;
    不然, 波浪号前缀将被替换成与指定登录名相关的家目录;

  - 如果波浪号前缀是 **~+** , shell 变量 **PWD** 的值将替换波浪号前缀;

    ::

       echo ~+ # 值等于 pwd 命令的返回结果;
               # 在脚本中使用代替 pwd;

    如果前缀是 **~-** , 将被替换成 shell 变量 **OLDPWD** [#]_ , 如果有的话;

    ::

       cd ~-/foo # 进入前一个目录的 foo 目录;


  - 如果波浪号后跟着数字 *N*, 或者跟着 *+N* 或 *-N*, 波浪前缀将被目录堆栈中的相应元素替换 [#]_,
    如同它通过在波浪前缀中跟着波浪号的字符作为参数调用了内置命令 *dirs* 被显示一样;

    ::

       ~N  === dirs +N  === ~+N
       ~-N === dirs -N

    如果波浪前缀由不带前导的 '+' 或 '-' 的数字组成, 那么就假定是 '+';

shell 参数扩展
------------------------------------------------------------

'$' 作为参数扩展, 命令替换, 或者算术扩展的开头;
要展开的参数名称或符号可以括在大括号中, 这是可选的, 但它有助于保护变量,
使其从紧跟其后的字符中展开, 可以将其解释为名称的一部分;

当使用大括号时, 匹配结束大括号是第一个未被反引号逃脱或者不在引用字符内,
并且不在嵌套的算术表达式, 命令替换或者参数扩展中;

参数扩展的基本形式是 **${parameter}** . **parameter** 的值将被替换.
*parameter* 可以是上面说的 shell 参数或者数组引用;
当 *parameter* 是具有多个数字的位置参数时, 或者当参数后跟不被解释为其名称的一部分的字符时,
则需要使用大括号;

如果 *parameter* 的第一个字符是惊叹号(!), 并且这个 *parameter* 不是一个 *nameref*,
它将引入一个间接变量的级别;
bash 使用由 *parameter* 剩余部分形成的作为变量名的变量的值, 然后此值被扩展并在余下的扩展中使用,
而不是 *parameter* 的值自身; 这叫间接扩展; 如果 *parameter* 是 *nameref* ,
这将扩展到被 *parameter* 引用的变量的名字以取代执行完全间接扩展;
但是有例外: 就像下面所说的 *${!prefix*}* 和 *${!prefix[@]}* ;
感叹号必须紧跟着左大括号以产生间接;

当不执行子字符串扩展时，请使用下面描述的形式;
Bash 测试参数其值是未设或者为空; 省略冒号导致仅测试参数是否未设;
换句话说, 如果包括冒号, 操作符将检测 *parameter* 是否存在并且它的值是否为空;
如果省略冒号, 仅检测存在性;

::

   ${parameter:-word}   # 若 parameter 未设或为空, 将替换为 word 的扩展; 否则就替换为 parameter 的值;
   ${parameter:=word}   # 若 parameter 未设或为空, word 的扩展将被分配给 parameter;
                        # 接着, parameter 的值被替换; 位置参数和特殊参数不会以这种方式被分配;
   ${parameter:?word}   # 若 parameter 未设或为空, word (如果 word 不存在,
                        # 则提示 parameter 未设或者为空) 的扩展将被写到标准错误,
                        # 且 shell 将退出, 如果此 shell 是非交互式的;
			# 否则, 将被替换 parameter 的值;
   ${parameter:+word}   # 如果 parameter 未设或为空, 什么都不会被替换; 否则, 将替换为 word 的扩展;



- ``${parameter:offset}``  ``${parameter:offset:length}``

  这叫子字符串扩展; 扩展到从 *offset* 指定的字符开始的 *length* 个长度的 *parameter* 值的字符串；
  如果 *parameter* 是 '@' 字符, 一个由  '@' 或  或 '*'的索引数组, 或者关联数组名, 将与下述有所不同.
  如果省略 *length* ，将扩展到由 *offset* 开始的字符到 *parameter* 值结束的子串;
  *length* 和 *offset* 是算术表达式;

  如果 *offset* 求值为小于 0 的数字, 该值被用作一个在字符串里从 *parameter* 值的结尾的偏移;
  如果 *length* 求值为小于 0 的数字, 将被解释为一个在字符串里的从 *parameter* 值的结尾的偏移而不是多个字符,
  并且扩展是 *offset* 和那个结果之间的字符串;
  注意, 负偏移必须被至少一个空格跟着的冒号分隔以防止与 ’： 扩展混淆;

  ::

     $ string=0123456789abcdefgh
     $ echo ${string:7}
     7890abcdefgh
     $ echo ${string:7:0}
     
     $ echo ${string:7:2}
     78
     $ echo ${string:7:-2}
     7890abcdef
     $ echo ${string: -7:0}
     
     $ echo ${string: -7:2}
     bc
     $ echo ${string: -7:-2}
     bcdef
     $ set -- 01234567890abcdefgh
     $ echo ${1:7}
     7890abcdefgh
     $ echo ${1:7:0}
     
     $ echo ${1:7:2}
     78
     $ echo ${1:7:-2}
     7890abcdef
     $ echo ${1: -7}
     bcdefgh
     $ echo ${1: -7:0}
     
     $ echo ${1: -7:2}
     bc
     $ echo ${1: -7:-2}
     bcdef
     $ array[0]=01234567890abcdefgh
     $ echo ${array[0]:7}
     7890abcdefgh
     $ echo ${array[0]:7:0}
     
     $ echo ${array[0]:7:2}
     78
     $ echo ${array[0]:7:-2}
     7890abcdef
     $ echo ${array[0]: -7}
     bcdefgh
     $ echo ${array[0]: -7:0}
     
     $ echo ${array[0]: -7:2}
     bc
     $ echo ${array[0]: -7:-2}
     bcdef


  如果参数是 ’@‘， 结是从 *offset* 开始的 *length* 个长度的位置参数;
  接受一个比最大位置参数大的负 *offset* , 这样一个 *-1* 的偏移到最后的位置参数;
  如果 *length* 求值为一个小于 0 的数字, 将引起扩展错误;

  ::

     $ set -- 1 2 3 4 5 6 7 8 9 0 a b c d e f g h
     $ echo ${@:7:0}
     
     $ echo ${@:7:2}
     7 8
     $ echo ${@:7:-2}
     bash: -2: 子串表达式 < 0
     $ echo ${@: -7:2}
     b c
     $ echo ${@:0}
     bash 1 2 3 4 5 6 7 8 9 0 a b c d e f g h
     $ echo ${@:0:2}
     bash 1
     $ echo ${@: -7:0} # 返回空


  如果 *parameter* 是一由 '@' 或 '*' 做下标的索引数组名,
  该结果将是以 *${parameter[offset]}* 开始的 *length* 个长度的数组成员;
  接受一个相对大的指定数组最大索引的负的 *offset* ;
  如果 *length* 求值为一个比 0 小的数字, 将引起扩展错误;

  ::
     
     $ array=(0 1 2 3 4 5 6 7 8 9 0 a b c d e f g h)
     $ echo ${array[@]:7}
     7 8 9 0 a b c d e f g h
     $ echo ${array[@]:7:2}
     7 8
     $ echo ${array[@]: -7:2}
     b c
     $ echo ${array[@]: -7:-2}
     bash: -2: 子串表达式 < 0
     $ echo ${array[@]:0}
     0 1 2 3 4 5 6 7 8 9 0 a b c d e f g h
     $ echo ${array[@]:0:2}
     0 1
     $ echo ${array[@]: -7:0}
     
  应用于关联数组的子串扩展产生未定义的结果;

  子串索引是基于 0 的, 除非使用了位置参数, 在这种下, 索引默认以 1 开始;
  如果 *offset* 是 0 且使用了位置参数, 则 '$@' 被前缀到列表中;

- ``${!prefix*}``  ``${!prefix@}``

  扩展成以 *prefix* 开始的由 **IFS** 特殊变量的第一个字符分隔的变量的名称;
  当使用 '@' 且扩展出现在双引号里, 每一个变量名将扩展为一个独立的词;

- ``${!name[@]}``  ``${!name[*]}``

  如果 name 是数组变量, 将扩展成数组索引的列表;

  如果 name 不是数组, 如果 name 被设定将扩展为 0, 否则扩展为空;

  当使用 '@' 并且扩展出现在双引号中时, 每一个键将扩展为独立的词;

- ``${#parameter}``

  替换为 *parameter* 的扩展值以字符方式的长度;
  如果 *parameter* 是 '*' 或者 '@' , 替换的值是位置参数的个数;
  如果 *parameter* 是以 '*' 或者 '@' 作下标的数组名, 替换的值将是数组中元素的个数;
  如果 *parameter* 是一个以负数作下标的索引数组名, 则该数被解释为相对于大于 *parameter* 最大索引的一个数,
  所以负索引从数组末尾开始计数, 且索引 -1 引用最后一个元素;

- ``${parameter#word}``  ``${parameter##word}``

  *word* 被扩展以产生一个匹配模式, 就像文件名扩展;
  如果模式匹配了 *parameter* 的扩展值的开头,
  那么扩展的结果将是删除了最短匹配模式(使用 '#')或最长匹配模式(使用 '##')匹配的 *parameter* 的扩展值;

  如果 *parameter* 是 '@' 或 '*', 匹配模式移除的操作将被依次应用到每一个位置参数上, 且扩展结果是结果列表;

  如果 *parameter* 是带有 '@' 或 '*' 下标的数组变量, 匹配模式移除的操作将被依次应用到每一个数组成员,
  且扩展结果是结果列表;

- ``${parameter/pattern/string}``

  *partern* 被扩展以生成一个匹配模式, 就像是文件名扩展;

  *parameter* 被扩展, 模式与它的值的最长匹配被字符串替换;
  如果 *pattern* 以 '/' 开头, 所有的 *pattern* 匹配将被以 *string* 取代;
  一般情况下, 仅第一次匹配被替换;

  如果 *pattern* 以 '#' 开始, 则必须匹配 *parameter* 扩展值的开始;

  如果 *pattern* 以 '%' 开始, 则必须匹配 *patameter* 扩展值的结尾;

  如果 *string* 为空, 则 *pattern* 的匹配将被删除并且跟在 *pattern* 后的 '/' 会被遗弃;

  如果 **nocasematch** shell 选项被打开, 该匹配会在不考虑大小写字母的情况被执行;

  如果 *parameter* 是 '@' 或 '*', 替换操作将依次被应用到每一个位置参数上,
  并且扩展结果是结果列表;

  如果 *parameter* 是带有 '@' 或 '*' 下标的数组变量, 替换操作将被依次应用到每一个数组成员,
  并且扩展结果是结果列表;

- ``${parameter^pattern}``  ``${parameter^^pattern}``  ``${parameter,pattern}``  ``${parameter,,pattern}``

  此扩展修改了 *parameter* 中字母字符的大小写;

  *pattern* 只能匹配单个字符;

  **^** 操作符把匹配了 *pattern* 小写字母转换成大写; **,** 操作符与 '*' 相反;
  '^' 和 ',' 仅匹配扩展值中的第一个字符;

  **^^** 或 **,,** 转换每一个匹配到的在扩展值中的字符 [#]_;

  .. warning::
     '^^' 和 ',,' 匹配不成功, 原因未知;

  如果没有 *pattern* , 将被用 '?' 处理, 即匹配每一个字符;

  如果 *parameter* 是 '@' 或 '*' , 大小写修改将被依次应用到每一个位置参数上,
  并扩展为结果列表;

  如果 *parameter* 是带有 '@' 或 '*' 的 *数组变量*,
  大小写修改将被依次应用到每一个数组成员, 并扩展为结果列表;

- ``${parameter@operator}``

  根据 *operator* 的值, 展开式可以是 *parameter* 值的转换, 也可以是关于 *parameter* 本身的信息;

  所有的 *operator* 都是单字符;

  - **Q** : 扩展是一个字符串, 它是以能够作为输入被重复使用的形式被引用的 *parameter* 的值;
  - **E** : 扩展是一个字符串, 该字符串是与$'...'引号机制一样扩展的反斜杠转义序列的参数值;
  - **P** : 扩展是一个字符串, 它是扩展 *parameter* 值的结果, 就像它是一个提示字符串一样;
  - **A** : 扩展是赋值语句或声明命令形式的字符串, 如果求值, 则使用其属性和值重新创建参数;
  - **a** : 扩展是由表示参数属性的标志值组成的字符串;

  如果 parameter 是 '@' 或者 '*', 同上; 如果 parameter 是带有 '@' 或 '*' 的 *数组变量*, 同上;



命令替换
------------------------------------------------------------

命令替换允许命令的输出替换命令本身; 命令替换发生在以下情况:

::

   $(command) # 新式命令替换
   `command`  # 老式命令替换

Bash通过在子shell环境中执行命令, 并用命令的标准输出替换命令替换,
删除所有的尾部新行，从而执行扩展;
嵌入式换行不会被删除, 但是它们可能在单词拆分期间被移除;
命令替换 **$(cat file)** 能够被等价但更快的 **$(< file)** 取代;

当使用老式的反引号替换形式时, 反斜线保留其字面意思, 跟在 '$', '`', '\' 后面的除外;
前面没有反斜线的第一个反引号终止命令替换;
当使用 **$(command)** 形式时, 所有的在括号中的字符串将组成命令, 没有一个会被特殊处理;

命令替换可嵌套. 当使用反引号形式来嵌套时, 可用反斜线来转义内部反引号;

如果替换出现在双引号内, 单词拆分和文件名扩展将不会对结果执行;


算术展开
------------------------------------------------------------

算术展开允许算术表达式的求值和结果的替换;

::

   $(( expresssion ))

表达式被好像它在双引号中一样处理, 但是括号内的双引号没有专门处理;
表达式中的所有符号都经过参数和变量展开, 命令替换和引用移除;
该结果被视为待求值的算术表达式;
算术表达式可嵌套;

根据以下的规则执行求值 `shell 算术运算 <https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic>`_;
如果表达式非法, 则BASH打印一条指示标准错误失败且不发生替换的消息;


.. rubric:: Footnotes

.. [#] 即 ~ 总是代表当前用户名;
.. [#] 即上一个之前的那个 PWD;
.. [#] 要配合 pushd popd dirs 一起使用才能看出效果, 注意, N 从 0 开始索引, -N 是反向索引目录栈;
.. [#] 实际发现好像并没有发生转换行为, 可能是我的匹配模式有问题;

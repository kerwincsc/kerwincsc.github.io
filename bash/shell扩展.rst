shell扩展
======================================================================

shell有7种扩展:

   
花括号扩展
------------------------------------------------------------

介绍: 花括号展开是一种可以产生任意字符串的机制;

特性:

  - 展开优先级最高, 开展后保留其它展开的特殊字符;
  - 可嵌套;
  - 展开结果不会被排序;
  - 从左向右展开;
  - 形如 {x..y[..incr]}, 是序列展开, *incr* 是步长, x 和 y 必须同时是单字符或是数字;

    此序列可以是递增的, 也可以是递减的; 递减时, *incr* 既可以是正数也可以是负数,
    且只能是整数;

  - BASH 对花括号内的扩展或文本的上下文不应用任何句法解释;

    为了防止与参数展开产生冲突, 字符串“${”不被当作是花括号扩展的合格条件;

格式正确的括号展开式必须包含无引号的开括号和关括号，以及至少一个无引号的逗号或有效的序列表达式;

可以用反斜线引用 { 或 “,”, 以防止它被看作括号表达式的一部分;

举例:

  ::

     bash$ echo a{d,c,b}e
     ade ace abe

     bash$ echo a{2..6} ; echo a{c..f}c
     a2 a3 a4 a5 a6
     acc adc aec afc

     bash$ echo a{6..2..-2}c ; echo a{6..2..2}c
     a6c a4c a2c
     a6c a4c a2c

     bash$ echo a{a..g..2} ; echo a{g..a..3} ; echo a{g..a..-3}
     aa ac ae ag
     ag ad aa
     ag ad aa

     bash$ echo a{a..z..c}
     a{a..z..c}


波浪号扩展
------------------------------------------------------------

如果一个单词以一个未被引用的波浪字符('~')开始,
所有的直到第一个未引用的斜线的字符(或者是所有的字符, 如果没有未被引用的斜线)被认为是一个 *波浪号前缀*;


特性:

  - 如果波浪号前缀内没有字符被引用, 则波浪号前缀中, 跟着波浪号的字符串将被当成是 **登录名**;

    ::

       ~foo # 这种形式将把 foo 当成是用户名; 如果不存在 foo 用户, 则报错;
            # 配合 cd 使用, 则进行 foo 用户家目录;


    如果登录名为空字符串, 波浪号将被 shell 变量 **HOME** 所替换 [#]_;

    如果 **HOME** 未设置, 将被替换成用户执行 shell 的家目录;
    不然, 波浪号前缀将被替换成与指定登录名相关的家目录;

  - 如果波浪号前缀是 **~+** , shell 变量 **PWD** 的值将替换波浪号前缀;

    ::

       echo ~+ # 值等于 pwd 命令的返回结果;
               # 在脚本中使用代替 pwd;

    如果前缀是 **~-** , 将被替换成 shell 变量 **OLDPWD** [#]_ , 如果有的话;

    ::

       cd ~-/foo # 进入前一个目录的 foo 目录;


  - 如果波浪号后跟着数字 *N*, 或者跟着 *+N* 或 *-N*, 波浪前缀将被目录堆栈中的相应元素替换 [#]_,
    如同它通过在波浪前缀中跟着波浪号的字符作为参数调用了内置命令 *dirs* 被显示一样;

    ::

       ~N  === dirs +N  === ~+N
       ~-N === dirs -N

    如果波浪前缀由不带前导的 '+' 或 '-' 的数字组成, 那么就假定是 '+';

shell 参数扩展
------------------------------------------------------------

'$' 作为参数扩展, 命令替换, 或者算术扩展的开头;
要展开的参数名称或符号可以括在大括号中, 这是可选的, 但它有助于保护变量,
使其从紧跟其后的字符中展开, 可以将其解释为名称的一部分;

当使用大括号时, 匹配结束大括号是第一个未被反引号逃脱或者不在引用字符内,
并且不在嵌套的算术表达式, 命令替换或者参数扩展中;

参数扩展的基本形式是 **${parameter}** . **parameter** 的值将被替换.
*parameter* 可以是上面说的 shell 参数或者数组引用;
当 *parameter* 是具有多个数字的位置参数时, 或者当参数后跟不被解释为其名称的一部分的字符时,
则需要使用大括号;

如果 *parameter* 的第一个字符是惊叹号(!), 并且这个 *parameter* 不是一个 *nameref*,
它将引入一个间接变量的级别;
bash 使用由 *parameter* 剩余部分形成的作为变量名的变量的值, 然后此值被扩展并在余下的扩展中使用,
而不是 *parameter* 的值自身; 这叫间接扩展; 如果 *parameter* 是 *nameref* ,
这将扩展到被 *parameter* 引用的变量的名字以取代执行完全间接扩展;
但是有例外: 就像下面所说的 *${!prefix*}* 和 *${!prefix[@]}* ;
感叹号必须紧跟着左大括号以产生间接;

当不执行子字符串扩展时，请使用下面描述的形式;
Bash 测试参数其值是未设或者为空; 省略冒号导致仅测试参数是否未设;
换句话说, 如果包括冒号, 操作符将检测 *parameter* 是否存在并且它的值是否为空;
如果省略冒号, 仅检测存在性;

::

   ${parameter:-word}   # 若 parameter 未设或为空, 将替换为 word 的扩展; 否则就替换为 parameter 的值;
   ${parameter:=word}   # 若 parameter 未设或为空, word 的扩展将被分配给 parameter;
                        # 接着, parameter 的值被替换; 位置参数和特殊参数不会以这种方式被分配;
   ${parameter:?word}   # 若 parameter 未设或为空, word (如果 word 不存在,
                        # 则提示 parameter 未设或者为空) 的扩展将被写到标准错误,
                        # 且 shell 将退出, 如果此 shell 是非交互式的;
			# 否则, 将被替换 parameter 的值;
   ${parameter:+word}   # 如果 parameter 未设或为空, 什么都不会被替换; 否则, 将替换为 word 的扩展;

.. rubric:: Footnotes

.. [#] 即 ~ 总是代表当前用户名;
.. [#] 即上一个之前的那个 PWD;
.. [#] 要配合 pushd popd dirs 一起使用才能看出效果, 注意, N 从 0 开始索引, -N 是反向索引目录栈;

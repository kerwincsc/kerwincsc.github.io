BASH
======================================================================

Shell 基本特性
------------------------------------------------------------

shell 操作
++++++++++++++++++++++++++++++++++++++++++++++++++

shell 的执行顺序:

#. 从一个文件, 从一个由 **-c** 调用选项提供的字符串, 或者从用户终端读取输入;
#. 遵循引用规则, 将输入分解为单词和运算符;

   这些符号被元字符分隔;
   别名扩展也在这步执行;

#. 将这些符号解析成简单的且混合的命令;
#. 执行 shell 的变量扩展, 将扩展开的符号分解成文件名, 命令和参数的列表;
#. 执行所有必要的重定向, 然后从参数列表中移除所有的重定向符号和它们操作对象;
#. 执行命令
#. 可选择地等待命令的完成(&), 然后收集它的退出状态;

引用
++++++++++++++++++++++++++++++++++++++++++++++++++

引用是用来移除对 shell 有特殊意义的字符或单词.

引用可被用来取消对特殊字符的特殊对待,
防止保留字被识别和防止参数扩展;

三种引用机制:

- 转义字符 ``\``
  对特定字符进行转义;
  如果一命令命令过长, 需要折行书写, 使用 / 确保是同一行的命令;

- 单引号 ``'``
  以单引号闭合的字符在单引号中保留了每个字符的字面值;
  一个单引号不会出现在单引号之间, 即使它的前面有一个反斜杠;

- 双引号 ``"``

  双引号里的字符将保留其字面值,
  以下除外: ``$ ` \`` 和打开历史展开功能时的 ``!``

  当处于 POSIX 模式中:
    - 即使打开了历史展开功能,
      双引号内的 **!** 也没有特殊意义;
    - 双引号中的'$' 和 '`' 保留自身的特殊意义;
    - 反引号后仅跟着如下符号: '$' , '`', '"', '\' 或者 *newline* 时,
      才保留其特殊意义;
    - 在双引号内, 被这些字符跟随的反斜杠将被移除.
    - 没有特殊意义字符之前的反引号将不作修改(不会被移除).

  在双引号里的一个双引号, 它之前有反引号的可被引用;

  如果打开, 除非出现在双引号内的 '!' 使用反引号逃逸, 否则历史命令展开将被执行;
  在 '!' 之前的反引号不会被移除;

  出现在双引号里的特殊字符 '*' 和 '@' 有特殊的意义;


shell 命令
++++++++++++++++++++++++++++++++++++++++++++++++++

- 命令的退出状态
  如果命令被信号终止, 则退出状态为 128+信号数;
  比如, 被 Ctrl+c 中止的命令退出状态码是 130(128+2);

管道
++++++++++++++++++++++++++++++++++++++++++++++++++

- ``|   |&``
- ``command1 |& command2``
  将 command1 的标准输出和标准错误作为 command2 的输入;
  等同于 **command1 2>&1 | command2** ;
- 标准错误到标准输出的隐式重定向在任一由命令指定的重写向之后被执行;
- time / time -p
  time -p 以 posix 形式输出时间;

  time 在 posix 模式下是没有多余的选项的, 其后跟 **-** 将会报错;

- `TIMEFORMAT` 显示命令的执行时间;

命令列表
++++++++++++++++++++++++++++++++++++++++++++++++++

- 命令列表是被 ``; & && ||`` 中的某个分隔的一个或多个管道的序列;
- 列表操作符中, **&&** 和 *||* 优先级相同, *;* 和 *&* 优先级相同;
- 一个或多个换行符的序列可能出现在列表中以分隔命令, 其等价于分号;
- 当作业控制不活动时, 异步命令的标准输入 (在没有任何显式重定向功能的情况下)
  将从 /dev/null 被重定向
- 被 ; 分隔的命令依次被执行;
  shell 轮流等待每个命令去终结;
  最后一个命令的退出状态作为整个命令列表的退出状态;
- and 和 or 列表:
  ``cmd1 && cmd2`` 仅当 cmd1 的退出状态为 0, 才执行 cmd2;

  ``cmd1 || cmd2`` 仅当 cmd1 的退出状态不为 0, 才执行 cmd2;

复合命令
++++++++++++++++++++++++++++++++++++++++++++++++++

循环构造
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
- until
  - ``until test-commands; do consequent-commands; done``

- while
  - ``while test-commands; do consequent-commands; done``

- for
  - ``for name [ [in [words …] ] ; ] do commands; done``
  - ``for (( expr1 ; expr2 ; expr3 )) ; do commands ; done``

  

历史记录
------------------------------------------------------------

``-o history`` 打开;

#. shell 变量
   **HISTSIZE** 历史记录大小, 默认500;

   **HISTIGNORE and HISTCONTROL**

   **HISTFILE** 默认值是 ~/.bash_history, bash 启动时读取此变量指定的文件
   中的记录作为历史记录;
   
   **HISTFILESIZE**
   
   **HISTTIMEFORMAT**

#. shell 选项
   histappend
   
   cmdhist
   
   lithist

#. 内置命令

  fc [#fc]_ [-e ename] [-lnr] [first] [last]

  fc -s [pat=rep] [command]

fc -l 仅列出最近的 16 条命令;

fc -l 100 仅列出 第100条到最近一条的命令;

fc -l 10 100 列出指定范围的命令;

fc -l -n 列出命令时, 不显示命令的序号;

fc -l -r 反向列出命令;

fc -e emacs 以 emacs 打开并显示最近一条命令;

   

#. 变量 ``FCEDIT`` 指定了显示或修改命令的编辑器

.. rubric:: 注

.. [#fc] Fix Command

端口扫描
======================================================================

- 途径

  - 端口对应网络服务及应用端程序
  - 服务端程序的漏洞通过端口攻入
  - 发现开放端口
  - 更具体的攻击面

- UDP 端口扫描

  - 假设 ICMP port-unreachable 响应代表端口关闭

    目标系统不响应 ICMP port-unreachable 时, 可能产生误判;

  - 完整的 UDP 应用层请求

     - 准确性高
     - 耗时巨大

  - Scapy UDP Scan

    - 端口关闭: ICMP port-unreachable
    - 端口开放: 没有回包
    - 了解每一种基于UDP的应用层包结构很有帮助
    - 误判

    - ``sr1(IP(dst="1.1.1.1")/UDP(dport=65432), timeout=5, verbose=0)``

  - Nmap

    - nmap -sU 1.1.1.1

      - 默认扫描 1000 个端口
      - ICMP host-unreachable

    - nmap -sU 1.1.1.1 -p 53
    - nmap -iL iplist.txt -p 1-200

- TCP 端口扫描

  - 基于连接的协议
  - 三次握手
  - 隐蔽扫描 --- syn

    - 不建立完整连接
    - 应用日志不记录行为 --- 较隐蔽

      仅应用层不进行记录, 网络层审计还是可以发现的;

  - 僵尸扫描

    现在还能做到僵尸扫描么?

    - 极度隐蔽
    - 使用条件较为苛刻
    - 可伪造源地址(必须1)
    - 选择僵尸机(必须2)

      - 闲置系统
      - 系统使用递增的 IPID [#]_

	- 0
	- 随机

    - 实现过程

      - 端口打开的情况

	#. 扫描者向僵尸机发送 **SYN/ACK** 

	#. 僵尸机返回 **RST**

	   因为未握手, 所以只能返回 **RST** , 此包中包含了 IPID, 设为 X;

	#. 扫描者 ``伪造源地址(僵尸机的地址)`` (可伪造源地址的需求) 向目标机器发送 **SYN** ;

	#. 目标机器返回 **SYN/ACK** (端口开放的情况) 给僵尸机(背锅侠)

	#. 由于僵尸机并未请求与目标机的连接,
	   故僵尸机会返回 **RST**, IPID 将为 X+1 (这就是需要使用递增 IPID 的机器的理由);

	#. 最后, 扫描者向僵尸机再次发送 **SYN/ACK** ,
	   僵尸机返回 **RST** , 此RST包中 IPID 为 X+2, 则确认指定端口开放;

      - 端口关闭的情况

	#. 扫描者向僵尸机发送 **SYN/ACK**

	#. 僵尸机返回 **RST**

	#. 扫描者 ``伪造源地址(僵尸机的地址)`` (可伪造源地址的需求) 向目标机器发送 **SYN**

	#. 目标机器返回 **RST** (端口关闭的情况) 给僵尸机(背锅侠)

	   僵尸机不做任何处理, 即 IPID 不会增加1;

	#. 扫描者向僵尸机再次发送 **SYN/ACK**

	   僵尸机返回 **RST** , 此RST包中 IPID 为 X+1, 则确认指定端口未开放;

  - 全连接扫描

    建立完整的三次握手进行的扫描;
  - 所有的 TCP 扫描方式都是基于三次握手的变化来判断目标端口状态

.. rubric:: Footnotes

.. [#] IP层的 Identification, IPID; 早期是递增的, 当前大多数系统已经随机产生 IPID

==============
 性能优化术语
==============

.. _load-average:

- 平均负载
  
  平均负载是指单位时间内, 系统处于 **可运行状态** 和 **不可中断状态** 的 ``平均进程数``,
  也就是 **平均活跃进程数**，和 **CPU 使用率** 并没有直接关系.

  包括了正在使用 CPU 的进程, 还包括等待 CPU 和等待 I/O 的进程.

  - 可运行状态的进程

    指正在使用 CPU 或者正在等待 CPU 的进程, 也就是我们常用 ps 命令看到的,
    处于 **R** 状态 (Running 或 Runnable) 的进程.

  - 不可中断状态的进程

    正处于 **内核态** 关键流程中的进程, 并且这些流程是不可打断的.

    比如最常见的是等待硬件设备的 I/O 响应, 也就是我们在 ps 命令中看到的 **D** 状态
    (Uninterruptible Sleep, 也称为 Disk Sleep) 的进程.

    比如, 当一个进程向磁盘读写数据时, 为了保证数据的一致性,
    在得到磁盘回复前, 它是不能被其他进程或者中断打断的, 这个时候的进程就处于不可中断状态.
    如果此时的进程被打断了, 就容易出现磁盘数据与进程数据不一致的问题.

    ``不可中断状态实际上是系统对进程和硬件设备的一种保护机制``

.. _cpu-usage:
    
- CPU 使用率

  是单位时间内 CPU 繁忙情况的统计, 跟平均负载并不一定完全对应.

  - CPU 密集型进程, 使用大量 CPU 会导致平均负载升高, 此时这两者是一致的

  - I/O 密集型进程，等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高

  - 大量等待 CPU 的进程调度也会导致平均负载升高, 此时的 CPU 使用率也会比较高

.. _cpu-register:

- CPU 寄存器

  是 CPU 内置的容量小, 但速度极快的内存

.. _program-counter:
  
- 程序计数器

  是用来存储 CPU 正在执行的指令位置, 或者即将执行的下一条指令位置

.. _cpu-context:

- CPU 上下文

  CPU 寄存器和程序计数器都是 CPU 在运行任何任务前, 必须的依赖环境, 因此被叫做 CPU 上下文;

.. _cpu-context-switch:

- CPU 上下文切换

  - 进程上下文切换, 线程上下文切换, 中断上下文切换

  先把前一个任务的 CPU 上下文 ( 也就是 CPU 寄存器和程序计数器 ) 保存起来,
  然后加载新任务的上下文到这些寄存器和程序计数器,
  最后再跳转到程序计数器所指的新位置, 运行新任务.

  而这些保存下来的上下文, 会 **存储在系统内核** 中,
  并在任务 **重新调度** 执行时 **再次加载** 进来.
  这样就能保证任务原来的状态不受影响, 让任务 **看起来还是连续运行**.

- 进程上下文切换

  

- 进程的用户态

  进程在用户空间运行时, 被称为进程的用户态

- 进程的内核态

  进程陷入内核空间的时候, 被称为进程的内核态

- 系统调用

  - 从用户态到内核态的转变, 需要通过系统调用来完成

  - 一次系统调用的过程, 其实是发生了两次 CPU 上下文切换

  - 系统调用过程中, 并不会涉及到虚拟内存等进程用户态的资源, 也不会切换进程

  - **系统调用过程通常称为特权模式切换, 而不是上下文切换**.

    但实际上, 系统调用过程中, CPU 的上下文切换还是无法避免的.


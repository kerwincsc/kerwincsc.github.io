==============
 优化问答 FAQ
==============

CPU 优化
==========

- 进程上下文切换跟系统调用有什么区别

  进程是由内核来管理和调度的, **进程的切换只能发生在内核态**. 所以,
  进程的上下文不仅包括了虚拟内存, 栈, 全局变量等用户空间的资源,
  还包括了内核堆栈, 寄存器等内核空间的状态.

  进程的上下文切换就比系统调用时多了一步: 在保存当前进程的内核状态和 CPU 寄存器之前,
  需要先把该进程的虚拟内存, 栈等保存下来; 而加载了下一进程的内核态后,
  还需要刷新进程的虚拟内存和用户栈.

- 什么时候会切换进程上下文

  **进程切换时才需要切换上下文**, 换句话说, 只有在进程调度的时候, 才需要切换上下文.

  Linux 为每个 CPU 都维护了一个就绪队列, 将活跃进程 ( 即正在运行和正在等待 CPU 的进程 )
  按照优先级和等待 CPU 的时间排序, 然后选择 **最需要 CPU 的进程**,
  也就是 **优先级最高** 和 **等待CPU时间最长的进程** 来运行.

- 进程在什么时候才会被调度到 CPU 上运行

  最容易想到的一个时机, 就是 **进程执行完终止** 了, 它之前使用的 CPU 会释放出来,
  这个时候再从就绪队列里, 拿一个新的进程过来运行.

  还有以下场景: 

  1. 为了保证所有进程可以得到公平调度, CPU 时间被划分为一段段的时间片,
     这些时间片再被轮流分配给各个进程. 这样, 当某个进程的 **时间片耗尽** 了,
     就会被系统挂起, 切换到其它正在等待 CPU 的进程运行.

  2. 进程在 **系统资源不足** ( 比如内存不足 ) 时, 要等到资源满足后才可以运行,
     这个时候进程也会被挂起, 并由系统调度其他进程运行.

  3. 当进程 **通过睡眠函数 sleep 这样的方法将自己主动挂起** 时, 自然也会重新调度.

  4. 当有 **优先级更高的进程运行** 时, 为了保证高优先级进程的运行,
     当前进程会被挂起, 由高优先级进程来运行.

  5. **发生硬件中断时**, CPU 上的进程会被中断挂起, 转而执行内核中的中断服务程序.

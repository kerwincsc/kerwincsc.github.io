==============
 优化问答 FAQ
==============

CPU 优化
==========

- 进程上下文切换跟系统调用有什么区别

  进程是由内核来管理和调度的, **进程的切换只能发生在内核态**. 所以,
  进程的上下文不仅包括了虚拟内存, 栈, 全局变量等用户空间的资源,
  还包括了内核堆栈, 寄存器等内核空间的状态.

  进程的上下文切换就比系统调用时多了一步: 在保存当前进程的内核状态和 CPU 寄存器之前,
  需要先把该进程的虚拟内存, 栈等保存下来; 而加载了下一进程的内核态后,
  还需要刷新进程的虚拟内存和用户栈.

- 什么时候会切换进程上下文

  **进程切换时才需要切换上下文**, 换句话说, 只有在进程调度的时候, 才需要切换上下文.

  Linux 为每个 CPU 都维护了一个就绪队列, 将活跃进程 ( 即正在运行和正在等待 CPU 的进程 )
  按照优先级和等待 CPU 的时间排序, 然后选择 **最需要 CPU 的进程**,
  也就是 **优先级最高** 和 **等待CPU时间最长的进程** 来运行.

- 进程在什么时候才会被调度到 CPU 上运行

  最容易想到的一个时机, 就是 **进程执行完终止** 了, 它之前使用的 CPU 会释放出来,
  这个时候再从就绪队列里, 拿一个新的进程过来运行.

  还有以下场景: 

  1. 为了保证所有进程可以得到公平调度, CPU 时间被划分为一段段的时间片,
     这些时间片再被轮流分配给各个进程. 这样, 当某个进程的 **时间片耗尽** 了,
     就会被系统挂起, 切换到其它正在等待 CPU 的进程运行.

  2. 进程在 **系统资源不足** ( 比如内存不足 ) 时, 要等到资源满足后才可以运行,
     这个时候进程也会被挂起, 并由系统调度其他进程运行.

  3. 当进程 **通过睡眠函数 sleep 这样的方法将自己主动挂起** 时, 自然也会重新调度.

  4. 当有 **优先级更高的进程运行** 时, 为了保证高优先级进程的运行,
     当前进程会被挂起, 由高优先级进程来运行.

  5. **发生硬件中断时**, CPU 上的进程会被中断挂起, 转而执行内核中的中断服务程序.

- 线程与进程的区别

  线程是调度的基本单位, 而进程则是资源拥有的基本单位.

  所谓内核中的任务调度, 实际上的调度对象是线程;
  而进程只是给线程提供了虚拟内存, 全局变量等资源.

  当进程只有一个线程时，可以认为进程就等于线程

  当进程拥有多个线程时, 这些线程会共享相同的虚拟内存和全局变量等资源.
  这些资源在上下文切换时是不需要修改的.

  线程也有自己的私有数据, 比如栈和寄存器等, 这些在上下文切换时也是需要保存的

- 怎么查看系统的上下文切换情况

  ``vmstat 5`` -> ``pidstat -w 5`` -> 

  - ``vmstat 5`` 每隔 5 秒 输出 1 组数据

    .. code-block:: shell

       $ vmstat 5
       procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
       r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
       0  0      0 7005360  91564 818900   0    0     0     0   25   33  0  0 100 0  0

    - cs (context switch) 是每秒上下文切换的次数

    - in (interrupt) 则是每秒中断的次数

    - r (Running or Runnable) 是 **就绪队列的长度**, 也就是正在运行和等待CPU的进程数

    - b (Blocked) 则是处于不可中断睡眠状态的进程数

  - ``pidstat -w 5`` 每隔 5 秒 输出 1 组数据

    .. code-block:: shell

       $ pidstat -w 5
       Linux 4.15.0 (ubuntu)  09/23/18  _x86_64_  (2 CPU)

       08:18:26      UID       PID   cswch/s nvcswch/s  Command
       08:18:31        0         1      0.20      0.00  systemd
       08:18:31        0         8      5.40      0.00  rcu_sched

    - cswch 表示每秒自愿上下文切换 (voluntary context switches) 的次数

    - nvcswch 表示每秒非自愿上下文切换 (non voluntary context switches) 的次数

- 中断只发生在内核态, 怎样才能知道中断发生的类型?

  - 从 ``/proc/interrupts`` 这个只读文件中读取
    
    /proc 实际上是 Linux 的一个虚拟文件系统, 用于内核空间与用户空间之间的通信.
    
    proc/interrupts 就是这种通信机制的一部分，提供了一个只读的中断使用情况.

    .. code-block:: shell

       # -d 参数表示高亮显示变化的区域
       $ watch -d cat /proc/interrupts
                  CPU0       CPU1
       ...
       RES:    2450431    5279697   Rescheduling interrupts
       ...

    找到变化速度最快的中断, 此例中是 :ref:`重调度中断(RES)<rescheduling_interrupts>`.

- 每秒上下文切换多少次才算正常 *****

  **取决于系统本身的 CPU 性能**.

  如果系统的上下文切换次数比较稳定, 那么从数百到一万以内, 都应该算是正常的.
  但当上下文切换次数超过一万次, 或者切换次数出现 **数量级的增长** 时,
  就很可能已经出现了性能问题.

  需要根据上下文切换的类型, 再做具体分析:

  - 自愿上下文切换变多了, 说明进程都在等待资源, 有可能发生了 I/O 等其他问题

  - 非自愿上下文切换变多了, 说明进程都在被强制调度, 也就是都在争抢 CPU,
    说明 CPU 的确成了瓶颈

  - 中断次数变多了, 说明 CPU 被中断处理程序占用,
    还需要通过查看 /proc/interrupts 文件来分析具体的中断类型.

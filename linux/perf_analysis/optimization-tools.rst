================
 性能优化工具集
================

性能分析
========

mpstat
------

- ``mpstat -P ALL 5`` **-P ALL** 表示监控所有 CPU, 后面数字 5 表示间隔 5
  秒后输出一组数据.

pidstat
-------

- ``pidstat -u 5 1`` 间隔 5 秒后输出一组数据, **-u** 表示 CPU 指标;
  可以用来查看具体的任务报告

execsnoop
---------

- 专为 **短时进程** 设计的工具.
  
- 通过 ftrace 实时监控进程的 exec() 行为

压测工具
========

stress
------

- 模拟 CPU 使用率 100% 的场景, 即不停地执行 sqrt

  .. code-block:: shell

     $ stress --cpu 1 --timeout 600

- 模拟 I/O 压力, 即不停地执行 sync

  .. code-block:: shell

     $ stress -i 1 --timeout 600
 
- 模拟多进程

  .. code-block:: shell

     # 模拟 8 个进程
     $ stress -c 8 --timeout 600

sysbench
--------

sysbench 是一个多线程的基准测试工具, 一般用来评估不同系统参数下的数据库负载情况.

- 模拟系统多线程调度切换的情况

  .. code-block:: shell

     # 在第一个终端运行
     # 以 10 个线程运行 5 分钟的基准测试, 模拟多线程切换的问题
     $ sysbench --threads=10 --max-time=300 threads run
     
     # 第二个终端运行 vmstat, 观察上下文切换情况
     # 每隔1秒输出1组数据（需要Ctrl+C才结束）
     $ vmstat 1
     ###### 注意 ######
     # r 列: 如果就绪队列 r 列的长度已经到远远超过系统 CPU 的个数,
     # 肯定会有大量的 CPU 竞争, 比如 CPU 数为 2, 就绪队列为 8.
     #
     # us (user) 和 sy (system) 列: 在模拟多纯种调度时,
     # 这两列的 CPU 使用率加起来可能会升到 100%, 如果系统 CPU 高于 用户 CPU,
     # 说明 CPU 主要是被内核占用了.
     #
     # in 列: 如果中断次数超出正常值, 说明中断处理也有潜在问题.
     #
     # 综上, 系统的就绪队列过长, 即正在运行和等待 CPU 的进程数过多,
     # 可能导致大量的上下文切换, 而上下文件切换又导致了系统 CPU 的占用率升高.
     

     # 第三个终端再用 pidstat 来看一下, CPU 和进程上下文切换的情况
     # 每隔1秒输出1组数据（需要 Ctrl+C 才结束）
     # -w 参数表示输出进程切换指标，而 -u 参数则表示输出CPU使用指标
     $ pidstat -w -u 1
     # 如果 pidstat 输出的上下文切换次数比 vmstat 的小太多,
     # 可能是因为没显示线程的数据, 要加上 -t, 才会输出线程的指标.

     # -wt 参数表示输出线程的上下文切换指标
     $ pidstat -wt 1
     

FAQ
~~~

- stress 模拟 I/O 压力时, iowait无法升高的问题.

  是因为案例中 stress 使用的是 **sync()** 系统调用, 它的作用是 **刷新缓冲区内存到磁盘中**.
  对于新安装的虚拟机, 缓冲区可能比较小, 无法产生大的 IO 压力,
  这样大部分就都是 **系统调用的消耗** 了. 所以, 你会看到只有系统 CPU 使用率升高.

  解决方法是使用 stress 的下一代 **stress-ng**, 它支持更丰富的选项,
  比如 ``stress-ng -i 1 --hdd 1 --timeout 600`` (--hdd 表示读写临时文件 )

- pidstat 输出中没有 **%wait** 的问题

  是因为 CentOS 默认的 sysstat 稍微有点老, 源码或者 RPM 升级到 11.5.5 版本以后就可以看到了.
  而Ubuntu的包一般都比较新, 没有这个问题.

- mpstat 无法观测的问题

  案例中是等待 5 秒后输出 1 次结果就停止了, 更好的做法是持续监控一段时间,
  比如持续观测 20 次: ``mpstat -P ALL 5 20``

===============
 InnoDB 重建表
===============

如果有一个表 A, 需要做空间收缩, 为了把表中的空洞去掉,
可以新建一个与表 A 结构相同的表 B, 然后按照主键 ID 递增的顺序,
把数据一行一行地从表 A 里读出来再插入到表 B 中.

由于表 B 是新建的表, 所以表 A 主键索引上的空洞, 在表 B 中就都不存在了.
显然, 表 B 的主键索引更紧凑, 数据页的利用率也更高.
如果把表 B 作为临时表, 数据从表 A 导入表 B 的操作完成后, 用表 B 替换 A,
从效果上看, 就起到了收缩表 A 空间的作用.

你可以使用 ``alter table A engine=InnoDB`` 命令来重建表.
在 MySQL 5.5 版本之前, 此命令的执行过程跟上面描述的差不多,
区别只是这个临时表 B 不需要自己创建,
MySQL 会自动完成转存数据, 交换表名, 删除旧表的操作.

显然, **花时间最多的步骤是往临时表插入数据的过程**,
如果在这个过程中, 有新的数据要写入到表 A 的话, 就会造成数据丢失.
因此, 在整个 DDL 过程中, 表 A 中不能有更新.
也就是说, **这个 DDL 不是 Online 的**.

而在 MySQL 5.6 版本开始引入的 Online DDLj, 对这个操作流程做了优化.
引入了 Online DDL 之后, 重建表的流程为:

  - 建立一个临时文件, 扫描表 A 主键的所有数据页;

  - 用数据页中表 A 的记录生成 B+ 树, 存储到临时文件中;

  - 生成临时文件的过程中, 将所有对 A 的操作记录在一个日志文件 (row log) 中,
    对应的是图中 state2 的状态;
    
  - 临时文件生成后, 将日志文件中的操作应用到临时文件,
    得到一个逻辑数据上与表 A 相同的数据文件, 对应的就是图中 state3 的状态.

  - 用临时文件替换表 A 的数据文件.

  .. image:: images/innodb_online_ddl.png

====================
 Mysql 常见运维问题
====================

- mysql 异常重启

  - 原因及解决方法

    1. 长连接累积, 可能导致内存占用过大, 被系统强行杀掉 (OOM), 从而表现为异常重启.

       - 定期断开长连接

	 使用一段时间, 或者程序里面判断执行过一个占用内存的大查询后, 断开连接,
	 之后要查询再重新连接;

       - 执行 ``mysql_reset_connection``

	 当 MySQL>=5.7, 在每次执行一个比较大的操作后.

	 此过程不需要重新做权限验证, 但是会将连接恢复到刚刚创建完时的状态

- 不要使用 **查询缓存**

  1. 查询缓存失效非常频繁

     只要有对一个表的更新, 这个表上所有的查询缓存都会被清空.

     对于更新压力大的数据库来说, **查询缓存** 的命中率非常低.

     只有当你的业务就一张静态表, 很长时间才会更新一次, 才适合用查询缓存

     Mysql8 中已经将查询缓存删掉了, 即没有这个功能了.

     - 关闭查询缓存

       将 ``query_cache_type`` 设为 **DEMAND**, 默认情况下, SQL 将不会使用查询缓存,
       而你确定要使用查询缓存的语句, 可以用 **SQL_CACHE** 显式指定

       .. code-block:: shell

	  mysql> select SQL_CACHE * from T where ID=10;x
       
- Oracle 迁移到 MySQL

  Oracle 数据库的默认隔离级别是 "读提交", 因此对于一些从 Oracle 迁移到 MySQL 的应用,
  为保证数据库隔离级别的一致, 一定要将 MySQL 的隔离级别设置为 "读提交"

- 搭建一些备库来增加系统的读能力

  常见的做法是用 **全量备份** 加上应用 **binlog** 来实现

- 什么时候删除 **回滚日志**

  系统会判断, 当没有事务再需要用到这些回滚日志时, 回滚日志会被删除;
  
  什么时候才不需要了呢, 就是当系统里没有比这个回滚日志更早的 read-view 的时候

- 为什么建议你尽量不要使用长事务

  **长事务** 意味着系统里面会存在很老的事务视图.
  由于这些事务随时可能访问数据库里面的任何数据, 所以这个事务提交之前,
  数据库里面它可能用到的回滚记录都必须保留, 这就会导致大量占用存储空间.

  案例:

      在 MySQL 5.5 及以前的版本, 回滚日志是跟数据字典一起放在 ibdata 文件里的,
      即使长事务最终提交, 回滚段被清理, 文件也不会变小.
      我见过数据只有 20GB, 而回滚段有 200GB 的库.
      最终只好为了清理回滚段, 重建整个库.

  除此之外, **长事务还占用锁资源**, 也可能拖垮整个库

- 长事务的产生原因

  有些客户端连接框架会默认连接成功后先执行一个 ``set autocommit=0`` 的命令.
  这就导致接下来的查询都在事务中, 如果是长连接, 就导致了意外的长事务.

- 查询长事务

  ``select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60`` 此命令用于查询持续时间超过 60s 的事务
  

- 如何启动事务

  - 显式启动事务

    ``begin`` 或 ``start transaction``,配套的提交语句是 ``commit``, 回滚语句是 ``rollback``

  - ``set autocommit=0``, 将会关掉此线程的自动提交.

    意味着, 如果只执行一个 select 语句, 事务就启动了, 并且不会自动提交.

    此事务持续存在直到你主动执行 commit 或 rollback, 或者断开连接.

  建议总是使用 ``set autocommit=1``, 通过显式语句的方式来启动事务.
 
  但是有的开发同学会纠结 "多一次交互" 的问题.
  对于一个需要频繁使用事务的业务, 第二种方式每个事务在开始时都不需要主动执行一次 "begin",
  减少了语句的交互次数. 如果你也有这个顾虑, 我建议你使用 **commit work and chain** 语法.

  在 **autocommit** 为 1 的情况下, 用 **begin** 显式启动的事务,
  如果执行 **commit** 则提交事务.

  如果执行 ``commit work and chain``, 则是提交事务并自动启动下一个事务,
  这样也省去了再次执行 **begin** 语句的开销.
  同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中.

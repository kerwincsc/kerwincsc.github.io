===========
 Rust 基础
===========

变量和常量的声明
================

变量
----

默认不可变;

不可变变量
**********

.. code-block:: rust
		
   let x = 5;

可变变量
********

.. code-block:: rust

   let mut x = 5;

常量
----

常量总是不能变;

.. code-block:: rust

   const MAX_POINTS: u32 = 100_000;

名称是 MAX_POINTS, 值是 100,000;

Rust 常量的命名规范是使用下划线分隔的大写字母单词,
并且可以在数字字面值中插入下划线来提升可读性;

不允许对常量使用 mut;

结构体
======

整个实例必须是可变的; Rust 并不允许只将某个字段标记为可变;

可以在函数体的最后一个表达式中构造一个结构体的新实例, 来隐式地返回这个实例;

字段初始化简写语法: 如果结构体中, 参数的名字和结构体的名称相同即可简写为

::

   fn build_user(email: String, username: String) -> User {
       User {
           email, // 原内容为: email: email,
	   username,
	   active: true,
	   sign_in_count: 1,
       }
   }

结构体更新语法: 使用旧实例的大部分值但改变其部分值来创建一个新的结构体实例

::

   let user2 = User {
       email: String::from("another@example.com"),
       username: String::from("anotherusername567"),
       ..user1 // 用旧实例 user1 的其余部分补全 user2 剩下的字段
   };

元组结构体
----------

有着结构体名称提供的含义, 但 **没有具体的字段名, 只有字段的类型**;

定义的每一个结构体有其自己的类型, 即使结构体中的字段有着相同的类型;

元组结构体实例类似于元组: 可以将其 *解构为单独的部分*,
也可以使用 **.** 后跟索引来访问单独的值;

使用
****

- 定义 ``struct Color(i32, i32, i32);``

- 初始化 ``let black = Color(0, 0, 0);``

- 使用 ``black.0``

类单元结构体
------------

一个没有任何字段的结构体;

类似于 **()**, 即 unit 类型;

用在你想要在某个类型上实现 trait 但不需要在类型中存储数据的时候;

枚举
====

可以将任意类型的数据放入枚举成员: 字符串, 数字类型, 结构体, 甚至是另一个枚举;

定义
----

.. code-block: rust

   enum Week {
       Monday,
       Tuesday,
       Wednedday,
       ...,
   }

控制流
======

match
-----

if let
------

match 的 " 简化版 ";

处理只匹配一个模式的值而忽略其他模式的情况;

可以在 if let 中包含一个 else;
else 块中的代码与 match 表达式中的 _ 分支块中的代码相同

常见集合
========

vector
------

vector 允许我们在一个单独的数据结构中储存多于一个的值;

在内存中彼此相邻地排列所有的值;

vector 只能储存相同类型的值;

字符串
-------

使用 to_string 方法从字符串字面值创建 String;

哈希 map
--------

包,模块,项目
============

结构体字段的公有性和私有性不受结构体自身的影响, 且可独立设定;
若结构体内有私有字段, 则必须提供公共关联函数来构造结构体实例;

将枚举设为公有, 则它的所有成员都将变为公有;

use
---

使用 use 将函数引入作用域的习惯用法: 将函数的父模块引入作用域;

优点是 可以清晰地表明函数不是在本地定义, 同时使完整路径的重复度最小化;

引入 结构体, 枚举和其他项时, 习惯是指定它们的完整路径;

嵌套路径来消除大量的 use 行;

如果希望将一个路径下 所有 公有项引入作用域，可以指定路径后跟 \*，glob 运算符;
Glob 会使得我们难以推导作用域中有什么名称和它们是在何处定义的;

as
----

使用 as 可解决: 将两个同名类型引入同一作用域的问题;

pub use
--------

当使用 use 关键字将名称导入作用域时, 在新作用域中可用的名称是私有的.
如果为了让调用你编写的代码的代码能够像在自己的作用域内引用这些类型,
可以结合 pub 和 use. 这个技术被称为 " 重导出 ( re-exporting )"

错误处理
========

如果你需要项目的最终二进制文件越小越好,
panic 时通过在 Cargo.toml 的 [profile] 部分增加 panic = 'abort',
可以由展开切换为终止

返回 Result 是定义可能会失败的函数的一个好的默认选择;

示例, 代码原型和测试都非常适合 panic;

泛型
====

- 定义

  高效处理重复概念的工具;

trait
=====

trait 可以与泛型结合来将泛型限制为拥有特定行为的类型, 而不是任意类型;

一个类型的行为由其可供调用的方法构成;

trait 体中可以有多个方法: 一行一个方法签名且都以分号结尾;

在方法签名后跟分号, 而不在大括号中提供其实现;

- 默认实现

  有时为 trait 中的某些或全部方法提供默认的行为,
  而不是在每个类型的每个实现中都定义自己的行为是很有用的.

  这样当为某个特定类型实现 trait 时, 可以选择保留或重载每个方法的默认行为;

  默认实现允许调用相同 trait 中的其他方法, 哪怕这些方法没有默认实现;

生命周期
=========

备忘
====

Rust中的基本数字类型都默认实现了 Copy Trait, 没有实现Copy Trait的变量，所有权就会被转移.

``derive`` may only be applied to **structs, enums and unions**

高阶LOOP
======================================================================

1. 迭代控制
------------------------------------------------------------

2. 计数型循环
------------------------------------------------------------

``for(as) ... <from|upfrom|downfrom> ... <to|upto|downto|below|above> ...``
起始短语, 终止短语, 步长短语:

#. 三个介词短语至少指定一个;
#. for 与 as 等价;
#. 默认起始为 0 , 终止为无穷, 步长为 1 ; 递减时, 无默认初值, 递增时,
   无默认终止值;

3. 循环集合和包
------------------------------------------------------------

#. 列表: 介词短语 ``in/on`` , 通过 **BY** 指定, 在列表中向下移动的函数,
   默认为 *CDR* ;

#. 向量: ``loop for ... across <字符向量|位向量>``

#. 哈希表/包: ``loop for ... being <the|each> <hash-keys|hash-values> <in|of> h using (<hash-value v|hash-key k>)``

4. 比较然后迭代
------------------------------------------------------------

``loop for var = initial-value-form [step-form] ...``

#. 首先, 初始化形式被求值给 var ;
#. 在后续的循环中, 以 *step-form* 的值更新 var ;
#. 如果无 then 部分, *initial-value-form* 将被重新求值以提供新值;

5. 局部变量
------------------------------------------------------------

``with var [= value-form]``

#. var 将在循环的首次迭代之前被初始化为 *value-form* 的值;
#. 循环结束后被删除;
#. 同中循环中, 可出现多个 with 子句, 每个子句以出现的顺序被独立地求值;
   后面的变量可依赖前面的变量
#. 完全无关的变量可以用 *and* 连接声明;
   即如果一个变量依赖另一个变量, 则需要用 with 单独声明;

6. 解构变量
------------------------------------------------------------

解构赋值给循环变量的列表值的能力 ::

  CL-USER> (loop for (a b) in '((1 2) (3 4) (5 6))
              do (format t "a: ~a; b: ~a~%" a b))

7. 值汇聚
------------------------------------------------------------

``verb form [ into var ]``

verb 可以是 *collect, append, nconc, sum, count, maximize, minimize* ,
及与之对应的进行时形式: *collecting, appending, ...* ;

两种 verb 用法完全相同, 只是英语上时态的区分, 便于阅读;

8. 无条件执行
------------------------------------------------------------

无条件执行的语句: 无条件构造 do

9. 条件执行
------------------------------------------------------------

LOOP的三种条件构造: *IF, WHEN, UNLESS* ;
其中, IF 与 WHEN 是同义词;

``conditional test-form loop-clause``

loop-clause 可以是 值汇聚子句, 无条件子句, 另一个条件子句;

10. 设置和拆除
------------------------------------------------------------

#. ``initially(序言)`` : 在所有局部循环变量被初始化以后,
   在循环体开始之前运行一次;
#. ``finally(尾声)`` : 在循环体的最后一次迭代结束以后运行;
#. initially 和 finally 部分的代码可以引用局部循环变量;
#. 即使迭代次数为 0 , *序言* 部分的代码也总是可以运行;
   但在以下情况中, *尾声* 部分的代码可能不会运行:

   .. note::
      * 执行了一个 return 语句;
      * RETURN , RETURN-FROM 或其他控制构造的传递操作
	在循环体中的一个LISP形式中被调用;
      * 循环被一个always, never 或 thereis 子句终止;

#. 尾声部分的代码中, 可使用 RETURN 或 RETURN-FROM 来提供
   显式的返回值, 且此返回值比其他汇聚或终止测试子句所提供
   的值具有更高的优先级;

#. 用循环关键字 named 为 LOOP 命名, 使 RETURN-FROM 一个特定的
   循环中返回, 出现在 LOOP 中的 named 子句必须是第一个子句;

11. 终止测试
------------------------------------------------------------

``loop-keyword test-form``

终止子句:
  * **温和** 的终止子句: 终止循环, 控制会传递给 finally : while, util,
    loop-from ; loop-from 在 do 子句中任意位置使用;
  * **极端** 的终止子句: 立即从循环中返回, 跳过任何连续的循环和尾声部分:
    always, never, thereis;
    其中, always 和 never 返回布尔值;

#. 即使终止测试未导致循环中止, 也依然为整个循环提供默认的返回值;
#. 如果循环不是因为这些终止测试中的一个而终止的话, 那么尾声部分
   还是有机会运行, 并返回值以替代所提供的默认值;

总结
------------------------------------------------------------

#. 如果有 ``named`` 子句, 则必须是第一个子句;
#. 在 named 子句后面是所有的 ``initially, with, for 和 repeat`` 子句;
#. 然后是主体子句: 有条件和无条件的执行, 汇聚和终止测试;
#. 以一个 ``finally`` 子句结束;


LOOP宏将展开成完成下列操作的代码:

.. hint::

  #. 初始化所有由 **with** 或 **for** 子句声明的局部变量, 以及由汇聚子句创建的隐含局部变量;
     初始值形式以子句出现在 LOOP 中的顺序依次求值;
  #. 以 ``initially 子句(序言)`` 出现在 LOOP 中的顺序, 执行任何由其提供的形式;
  #. 迭代, 同时按照下文描述的那样执行循环体;
  #. 以 ``finally 子句(尾声)`` 出现在循环中的顺序, 来执行任何由其提供的形式;
  

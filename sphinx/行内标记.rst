行内标记
======================================================================


交叉引用任意位置
------------------------------------------------------------

**:ref:**

  - 如果直接在区段标题之前放置标签, 可以这样引用 ``:ref:`label-name``` ::

      .. _label-name:

      Section to cross-reference
      --------------------------
      
      This is the text of the section.
      
      It refers to the section itself, see :ref:`my-reference-label`.


    适用于区段与引用不在同一源文件内 [#cross-ref]_;

    自动标签也适用于图像 ::

      .. _my-figure:

      .. figure:: whatever.png

	 Figure caption

    这样, ``:ref:`my-figure``` 将会插入链接文本为 "Figure caption" 的引用;
    figure 后的文件要指定后缀, 不然无法识别;

  - 没有放在区段标题之前的标签也能被引用 [#cross-ref-explicit]_, 只要给定一个显示的标题;

    语法如下: ``:ref:`Link title<label-name>``` ;

交叉引用文档
------------------------------------------------------------

**:doc:**

  - 链接到指定文档
  - 文件名可以以绝对或相对的方式指定; 如:

    如果引用 ``:doc:`parrot``` 出现在文档 **sketches/index** 内,
    那么这个链接会指向 **sketches/parrot**

    如果引用是 ``:doc:`/people``` 或者 ``:doc:`../people``` , 就会链接到 **people**

  - 如果没有显式指定链接文本 (如 ``:doc:`Monty Python members </people>``` ),
    链接的标题就会是给定文件的标题;

引用可下载文件
------------------------------------------------------------

**:download:**

用法: ``download:`this example script <../example.py>```

- 必须加文件后缀名, 而不是像上面引用文档或者引用任意位置一样需要省略 *.rst* , 否则会找不到文件;
- 可以显式指定链接文本, 这样就可以不用显示待下载的文件名了;
- 给定文件名相对于包含当前文件的目录的路径, 但如果是绝对路径, 则是相对于顶层源目录的路径;
- *example.py* 在编译时被拷贝到输出目录的 *_download* 文件夹, 并有一个指向它的链接;

交叉引用其它有趣的东西
------------------------------------------------------------

以下角色确实会创建交叉引用，但不引用对象;

- **:envvar:**

  环境变量; 生成引用条目; 如果 *envvar* 指令存在的话, 也会生成一个指向它的链接;

  用例列举: ::

    :envvar:`var_name`

    .. envvar:: var_name

       有关 var_name 的描述;

- **:token:**

  语法标记的名称; 常用来在 *productionlist* 指令间创建链接;

  这个目前不理解如何使用;

- **:keyword:** 关键字角色

  Python 中关键字的名称; 它会用那个名字创建指向一个引用标签的链接, 如果标签存在的话;

  用法举例: ::

    :keyword:`dig_basic`
    将会生成一个指向名为 dig_basic 的标签
    如果标签名不存在, 则会出警告, 并且无法创建链接;
    此角色的作用类似于交互引用任意位置的角色 :ref: ;
  

  :keyword:`dig_basic`

- **:option:** 选项角色

  一个可执行程序的命令行选项; 连字符是必须的;
  如果存在的话, 此命令产生一个指向 *option* 指令的链接;

  用法举例: ::

    :option:`-r` # 用在行内, 表明有对此选项的进一步解释;

    .. option:: -r # 此指令对应于 option 角色

       递归.       # 解释说明文字, 上下有空行会比较好;

    :option:`--module` # 长选项也是可以的;

    # option 指令中参数需要用尖括号括起来
    .. option:: --module <module_name> 

    # 这里已经不算正统用法了, 但仍然可以使用;
    :option:`rm`
    .. option:: rm
       -p 一些关于此选项的说明;

    # 联合 program 指令使用的正统用法, 适用于两个指令有相同的选项的场合;
    :option:`rm -r`
    :option:`svn -r`

    .. program:: rm
    .. option:: -r

       Work recursively

    .. program:: svn
    .. option:: -r

       Specify the revision to work upon.

    对于同选项的命令, 可用 program 指令加以区分;

- **:term:**

  此角色创建对术语表内术语的交叉引用;

  词汇表使用指令 **glossary** 创建, 包含术语的定义列表和定义.

  术语的描述和术语不一定要在同一文件内; 比如, Python 文档在 *glossary.rst* 内有一个全局的词汇表;

  如果词汇表中没有你指定的术语, 就会在编译期间发出警告;

  用法示意: ::

    :term:`name_of_term`

    .. glossary:: name_of_term description_of_term
    或者
    .. glossary:: name_of_term
       description_of_term

    注意: 术语和描述之间不能有空行;

其它语义标记
------------------------------------------------------------

- **:abbr:**

  缩写词; 如果 abbr 的内容包含带括号的解释, 将会被特殊对待;

  在HTML时会显示成 tool-tip ,仅在LaTeX才会输出; 举例: ::
    
    :abbr:`ICMP(Internet Control Message Protocol)`
    将会显示为带下划线的 ICMP, 并且当鼠标悬在上面会显示全称;

- **:command:**

  系统级别的命令，例如 rm; 举例 ::

    :command:`rm`
    在 sphinx_rtd_theme 主题下, 看不出来有非常明显的标记;
    只是 rm 这个指令被加粗显示了而已;

- **:dfn:**

  在文本中标记术语的定义实例; 不产生索引条目

  不知道怎么用, 也不知道干啥用的;


.. rubric:: Footnotes
.. [#cross-ref]
   严格地说, 也可以在同一源文件内引用, 但是意义不大;
.. [#cross-ref-explicit]
   也可以用于第一种情况, 如果你确实需要一个显式标题, 替换丑陋的标签名



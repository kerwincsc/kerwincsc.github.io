=======================================
Common lisp
=======================================


变量
--------------------------------------------------

let<--局部变量
########################################

``let`` 是一个最常用的 Common Lisp 的特殊操作符之一,
让你引入新的局部变量( ``(let VARLIST BODY...)`` ); ::

    > (let ((x 1) (y 2))
     (+ x y))
    3

变量只在 **let** 的函数体内有效;

一组变量与数值之后, 是一个有表达式的函数体, 表达式依序被求值;

defparameter<--全局变量
########################################

``defparameter`` 创建全局变量( ``(defparameter VAR VAL)`` ) ::

    > (defparameter *glob* 99)
    *GLOB*

一般全局变量在变量名前后加 ***** , 加以区别;

defconstant<--全局常量
########################################

``(defconstant VAR VAL)`` ::

    (defconstant limit (+ *glob* 1))


不需要给常量一个独一无二的名字, 因为如果有相同名字存在, 就会有错误产生(error);

检查某些符号, 是否为一个全局变量或常量, 使用 ``boundp`` 函数

赋值
--------------------------------------------------

在 Common Lisp 里, 最普遍的赋值操作符(assignment operator)是 ``setf`` ,
可给全局和局部变量赋值; ::

    > (setf *glob* 98)
    98
    > (let ((n 10))
       (setf n 2)
       n)
    2

如果 setf 的第一个实参是符号(symbol), 且符号不是某个局部变量的名字,
则 setf 把这个符号设为 **全局变量** ;

也就是说, 通过赋值, 你可以隐式地创建全局变量(即赋值默认就是创建全局变量);

不过, 一般来说, 还是使用 *defparameter* 明确地创建全局变量比较好

你不仅可以给变量赋值. 传入 setf 的第一个实参, 还可以是表达式或变量名.
在这种情况下, 第二个实参的值被插入至第一个实参所引用的位置; ::

    > (setf (car x) 'n)
    N
    > x
    (N B C)

setf 的第一个实参几乎可以是 *任何引用到特定位置的表达式* ;

所有这样的操作符在附录 D 中被标注为 “可设置的” (“settable”);

可以给 setf 传入（偶数）个实参 ::

    (setf a 'b
          c 'd
          e 'f)

等同于依序调用三个单独的 setf 函数: ::

    (setf a 'b)
    (setf c 'd)
    (setf e 'f)



列表
--------------------------------------------------

列表是由被括号包住的零个或多个元素来表示.
元素可以是任何类型, 包含列表本身.
使用列表 **必须要引用**, 不然 Lisp 会以为这是个函数调用.


你可以调用 list 来创建列表. 由于 list 是函数, 所以它的实参会被求值.

即函数的实参会被求值.


* Common Lisp 里有两种方法来表示空列表:

  你可以用一对不包括任何东西的括号来表示;

  用符号 nil 来表示空表;

你用哪种表示法来表示空表都没关系, 但它们都会被显示为 nil ;


不需要引用 nil (但引用也无妨), 因为 nil 是对自身求值的;

列表操作
##################################################

* 构造列表

函数 ``cons`` 构造列表;

函数 ``list`` 也可以构造列表;

函数 cons 和 函数 list 在构造列表上有什么不同, 以何种应用场景进行区分?


* 取出列表元素的基本函数

  * car 对列表取 car 返回第一个元素;

  * cdr 对列表取 cdr 返回第一个元素后的所有元素;

  如果我想取第二个元素, 应该怎么办? ::

    (car (cdr '(a b c d e)))


  如果取第三个, 怎么办? ::

    (car (cdr (cdr '(a b c d e))))
    或者
    (third '(a b c d e))

  此处的 ``third`` 是sbcl内置的函数;


逻辑运算
--------------------------------------------------

在 Common Lisp 里, 符号 t 是表示逻辑 真 的缺省值;

与 nil 相同, t 也是对自身求值的;

如何判断一个实参是否为列表: ::

    > (listp '(a b c))
    T

函数的返回值将会被解释成逻辑 真 或逻辑 假 时, 则称此函数为谓词(predicate);

在 Common Lisp 里, 谓词的名字通常以 ``p`` 结尾;

nil 在 Common Lisp 中有两个意思: 空列表 或者 逻辑假 ;

如果实参是一个空表, 则函数 ``null`` 返回真;

::

    > (null nil)
    T


如果实参是逻辑假, 则函数 not 返回真;

:: 

    > (not nil)
    T

逻辑操作符
####################################

``and`` 和 ``or`` :

* 两者都接受任意数量的实参, 但仅对能影响返回值的几个实参求值;

* 如果and所有的实参都为 **真** (即非 nil ), 那么 and 会返回最后一个实参的值;

* 如果and其中一个实参为 **假** , 那之后的所有实参都不会被求值;

* or 只要碰到一个为 **真** 的实参, 就停止对之后所有的实参求值;

* 以上这两个操作符称为 ``宏`` ; 宏和特殊的操作符一样, 可以绕过一般的求值规则;


条件运算
--------------------------------------------------

最简单的条件式是 ``if`` , 它是 **特殊操作符** ; ::

    (if COND THEN ELSE...)


输入输出
--------------------------------------------------

输出
########################################

最普遍的 Common Lisp 输出函数是 ``format`` ;

接受两个或两个以上的实参, 第一个实参决定输出要打印到哪里,
第二个实参是字符串模版;

剩余的实参, 通常是要插入到字符串模版,
用打印表示法(printed representation)所表示的对象; ::

    > (format t "~A plus ~A equals ~A. ~%" 2 3 (+ 2 3))
    2 plus 3 equals 5.
    NIL

输入
########################################

标准的输入函数是 ``read`` ;

当没有实参时, 会读取缺省的位置, 通常是顶层; ::

    (defun askem (string)
    (format t "~A" string)
    (read))

    > (askem "How old are you?")
    How old are you?29

    29

函数式编程
--------------------------------------------------

函数式编程意味着撰写 *利用返回值* 而工作的程序, 而不是修改东西;
它是 Lisp 的主流范式; 大部分 Lisp 的内置函数被调用是为了取得返回值, 而不是副作用;

举例来说, 函数 ``remove`` 接受一个对象和一个列表, 返回不含这个对象的新列表; ::

    > (setf lst '(c a r a t))
    (C A R A T)
    > (remove 'a lst)
    (C R T)

为什么不干脆说 remove 从列表里移除一个对象? 因为它不是这么做的, 原来的表没有被改变; ::

    > lst
    (C A R A T)

若你真的想从列表里移除某些东西怎么办? 在 Lisp 通常你这么做, 把这个列表当作实参,
传入某个函数, 并使用 setf 来处理返回值.

要移除所有在列表 x 的 a, 可以这么做 ::

    (setf x (remove 'a x))

函数式编程本质上意味着避免使用如 setf 的函数;
起初可能觉得这根本不可能, 更遑论去做了. 怎么可以只凭返回值来建立程序?

完全不用到副作用是很不方便的.
然而, 随着你进一步阅读, 会惊讶地发现需要用到副作用的地方很少.
*副作用用得越少, 你就更上一层楼.*

函数式编程最重要的优点之一是, 它允许交互式测试(interactive testing).
在纯函数式的程序里, 你可以测试每个你写的函数.
如果它返回你预期的值, 你可以有信心它是对的.
这额外的信心, 集结起来, 会产生巨大的差别.
当你改动了程序里的任何一个地方, 会得到即时的改变.
而这种即时的改变, 使我们有一种新的编程风格.
就像电话与信件, 让我们有一种新的通讯方式.

迭代
--------------------------------------------------

当我们想重复做一些事情时, 迭代比递归来得更自然.
典型的例子是用迭代来产生某种表格; ::

    (defun show-squares (start end)
      (do ((i start (+ i 1)))
          ((> i end) 'done)
        (format t "~A ~A~%" i (* i i))))


打印从 start 到 end 之间的整数的平方: ::

    > (show-squares 2 5)
    2 4
    3 9
    4 16
    5 25
    DONE

``do 宏`` 是 Common Lisp 里最基本的迭代操作符. 和 let 类似, do 可以创建变量,
而第一个实参是一组变量的规格说明列表. 每个元素可以是以下的形式: ::

    (variable initial update)

完整的函数形式如下 ::

    (do ((VAR INIT [STEP])...) (END-TEST [RESULT...]) BODY...)

其中 variable 是一个符号, initial 和 update 是表达式;
最初每个变量会被赋予 initial 表达式的值; 每一次迭代时, 会被赋予 update 表达式的值;
在 show-squares 函数里, do 只创建了一个变量 i . 第一次迭代时, i 被赋与 start 的值,
在接下来的迭代里, i 的值每次增加 1 ;

第二个传给 do 的实参可包含一个或多个表达式; 第二个实参的第一个表达式用来测试迭代是否结束.
在上面的例子中, 测试表达式是 (> i end) . 接下来在列表中的表达式会依序被求值, 直到迭代结束.
而最后一个值会被当作 do 的返回值来返回. 所以 show-squares 总是返回 done ;

do 的剩余参数组成了循环的函数体. 在每次迭代时, 函数体会依序被求值.
在每次迭代过程里, 变量被更新, 检查终止测试条件, 接着(若测试失败)求值函数体;

作为对比, 以下是递归版本的 show-squares: ::

    (defun show-squares (i end)
       (if (> i end)
         'done
         (progn
           (format t "~A ~A~%" i (* i i))
           (show-squares (+ i 1) end))))


唯一的新东西是 ``progn`` . progn 接受任意数量的表达式, *依序* 求值,
并 *返回最后一个表达式* 的值;

为了处理某些特殊情况, Common Lisp 有更简单的迭代操作符.
举例来说, 要遍历列表的元素, 你可能会使用 ``dolist`` .
以下函数返回列表的长度 ::

    (defun our-length (lst)
      (let ((len 0))
        (dolist (obj lst)
          (setf len (+ len 1)))
        len))

这里 dolist 接受这样形式的实参(variable expression), 跟着一个具有表达式的函数主体;
函数主体会被求值, 而变量相继与表达式所返回的列表元素绑定;
因此上面的循环说, 对于列表 lst 里的每一个 obj , 递增 len .
很显然这个函数的递归版本是 ::

    (defun our-length (lst)
      (if (null lst)
          0
          (+ (our-length (cdr lst)) 1)))

也就是说, 如果列表是空表, 则长度为 0 ; 否则长度就是对列表取 cdr 的长度加一.
递归版本的 our-length 比较易懂, 但由于它不是尾递归(tail-recursive)的形式,
效率不是那么高;

函数作为对象
--------------------------------------------------

函数在 Lisp 里, 和符号、字符串或列表一样, 是稀松平常的对象;
如果我们把函数的名字传给 function , 它会返回相关联的对象;
和 quote 类似,  ``function`` 是一个特殊操作符, 所以我们无需引用（quote）它的实参: ::

    > (function +)
    #<Compiled-Function + 17BA4E>

这看起来很奇怪的返回值, 是在典型的 Common Lisp 实现里, 函数可能的打印表示法;

到目前为止, 我们仅讨论过, 不管是 Lisp 打印它们, 还是我们输入它们, 
看起来都是一样的对象. 但这个惯例对函数不适用. 
一个像是 + 的内置函数 , 在内部可能是一段机器语言代码（machine language code）. 
每个 Common Lisp 实现, 可以选择任何它喜欢的外部表示法（external representation）

如同我们可以用 ``'`` 作为 quote 的缩写, 也可以用 ``#'`` 作为 function 的缩写: ::

    > #'+
    #<Compiled-Function + 17BA4E>

这个缩写称之为 **升引号** (sharp-quote).

和别种对象类似, 可以把函数当作实参传入. 有个接受函数作为实参的函数是 apply . 
apply 接受一个函数和实参列表, 并返回把传入函数应用在实参列表的结果: ::

    > (apply #'+ '(1 2 3))
    6
    > (+ 1 2 3)
    6

apply 可以接受任意数量的实参, 只要最后一个实参是列表即可: ::

    > (apply #'+ 1 2 '(3 4 5))
    15

函数 ``funcall`` 做的是一样的事情, 但不需要把实参包装成列表 ::

    > (funcall #'+ 1 2 3)
    6

.. hint:: 什么是 lambda ?

	  lambda 表达式里的 lambda 不是一个操作符. 而 **只是个符号** . 
	  在早期的 Lisp 方言里,  lambda 存在的原因是:由于函数在内部是用列表来表示, 
	  因此辨别列表与函数的方法, 就是检查第一个元素是否为 lambda . 

	  在 Common Lisp 里, 你可以用列表来表达函数, 
	  函数在内部会被表示成独特的函数对象. 因此不再需要 lambda 了. 
	  如果需要把函数记为 ::

	      ((x) (+ x 100))

	  而不是 ::

	      (lambda (x) (+ x 100))

	  也是可以的;
	  但 Lisp 程序员习惯用符号 lambda , 来撰写函数, 
	  因此 Common Lisp 为了传统, 而保留了 lambda ;


``defun 宏`` , 创建一个函数并给函数命名. 但函数不需要有名字, 
而且我们不需要 defun 来定义他们. 和大多数的 Lisp 对象一样, 我们可以直接引用函数;


要直接引用整数，我们使用一系列的数字；要直接引用一个函数，我们使用所谓的lambda 表达式。
一个 lambda 表达式是一个列表，列表包含符号 lambda ，接着是形参列表，
以及由零个或多个表达式所组成的函数体;

下面的 lambda 表达式，表示一个接受两个数字并返回两者之和的函数 ::

    (lambda (x y)
      (+ x y))

列表 *(x y)* 是形参列表，跟在它后面的是函数主体;

一个 lambda 表达式可以作为函数名。和普通的函数名称一样，
lambda 表达式也可以是函数调用的第一个元素 ::

    > ((lambda (x) (+ x 100)) 1)
    101

而通过在 lambda 表达式前面贴上 #' ，我们得到对应的函数 ::

    > (funcall #'(lambda (x) (+ x 100))
               1)

lambda 表示法除上述用途以外，还允许我们使用匿名函数;

类型
--------------------------------------------------

Lisp 处理类型的方法非常灵活。在很多语言里，变量是有类型的，得声明变量的类型才能使用它;
在 Common Lisp 里，数值才有类型，而变量没有;
你可以想像每个对象，都贴有一个标明其类型的标签;
这种方法叫做显式类型（manifest typing）。
你不需要声明变量的类型，因为变量可以存放任何类型的对象;

虽然从来不需要声明类型，但出于效率的考量，你可能会想要声明变量的类型;

Common Lisp 的内置类型，组成了一个类别的层级。对象总是不止属于一个类型。
举例来说，数字 27 的类型，依普遍性的增加排序，
依序是 fixnum 、 integer 、 rational 、 real 、 number 、 atom 和 t 类型;

函数 ``typep`` 接受一个对象和一个类型，然后判定对象是否为该类型，是的话就返回真; ::

    > (typep 27 'integer)
    T

展望
--------------------------------------------------

本章仅谈到 Lisp 的表面。然而，一种非比寻常的语言形象开始出现了;

首先，这个语言用单一的语法，来表达所有的程序结构;
语法基于列表，列表是一种 Lisp 对象。函数本身也是 Lisp 对象，函数能用列表来表示;
而 Lisp 本身就是 Lisp 程序。几乎所有你定义的函数，与内置的 Lisp 函数没有任何区别;

如果你对这些概念还不太了解，不用担心。 Lisp 介绍了这么多新颖的概念，
在你能驾驭它们之前，得花时间去熟悉它们;
不过至少要了解一件事：在这些概念当中，有着优雅到令人吃惊的概念;

Richard Gabriel 曾经半开玩笑的说， C 是拿来写 Unix 的语言。我
们也可以说， Lisp 是拿来写 Lisp 的语言。但这是两种不同的论述。
一个可以用自己编写的语言和一种适合编写某些特定类型应用的语言，是有着本质上的不同。
这开创了新的编程方法：你不但在语言之中编程，还把语言改善成适合程序的语言。
如果你想了解 Lisp 编程的本质，理解这个概念是个好的开始;

总结
--------------------------------------------------

#. Lisp 是一种交互式语言。如果你在顶层输入一个表达式， Lisp 会显示它的值;

#. Lisp 程序由表达式组成。表达式可以是原子，或一个由操作符跟着零个或多个实参的列表。
   前序表示法代表操作符可以有任意数量的实参;

#. Common Lisp 函数调用的求值规则： 依序对实参从左至右求值，
   接着把它们的值传入由操作符表示的函数。 
   quote 操作符有自己的求值规则，它完封不动地返回实参;

#. 除了一般的数据类型， Lisp 还有符号跟列表。
   由于 Lisp 程序是用列表来表示的，很轻松就能写出能编程的程序。

#. 三个基本的列表函数是 cons ，它创建一个列表； car ，它返回列表的第一个元素；
   以及 cdr ，它返回第一个元素之后的所有东西;

#. 在 Common Lisp 里， t 表示逻辑 *真* ，而 nil 表示逻辑 *假* 。
   在逻辑的上下文里，任何非 nil 的东西都视为 真 。
   基本的条件式是 if 。 and 与 or 是相似的条件式;

#. Lisp 主要由函数所组成。可以用 defun 来定义新的函数;

#. 自己调用自己的函数是递归的。一个递归函数应该要被想成是过程，而不是机器;

#. 括号不是问题，因为程序员通过缩排来阅读与编写 Lisp 程序;

#. 基本的 I/O 函数是 read ，它包含了一个完整的 Lisp 语法分析器，
   以及 format ，它通过字符串模板来产生输出;

#. 你可以用 let 来创造新的局部变量，用 defparameter 来创造全局变量;

#. 赋值操作符是 setf 。它的第一个实参可以是一个表达式;

#. 函数式编程代表避免产生副作用，也是 Lisp 的主导思维;

#. 基本的迭代操作符是 do

#. 函数是 Lisp 的对象。可以被当成实参传入，并且可以用 lambda 表达式来表示;

#. Lisp 里，是数值才有类型，变量没有类型;
